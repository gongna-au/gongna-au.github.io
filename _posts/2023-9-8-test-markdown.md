---
layout: post
title: 分布式面试题
subtitle:
tags: [分布式]
comments: true
---

**问题1**:什么是CAP原则？
**答案**：CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这3个基本需求，最多只能同时满足其中的2个。分区是必然存在的，所谓分区指的是分布式系统可能出现的字区域网络不通，成为孤立区域的的情况。

在满足一致性 的时候，N1和N2的数据要求值一样的，D1=D2。
在满足可用性的时候，无论访问N1还是N2，都能获取及时的响应。



**问题2**：请描述一下分布式系统中的一致性和最终一致性有什么区别？
**答案**：在分布式系统中，一致性指的是所有节点在同一时间看到的数据是一样的，这也就意味着**任何写入的新值将会立即被所有节点看到**。最终一致性则是指，在没有新的更新操作时，经过一段时间后，所有的读操作最终都能返回最后更新的值。

**问题3**：什么是分布式系统中的分区容错？
**答案**：分区容错指的是在分布式系统中，即使系统网络发生分区（网络连接中断），系统仍然能够正常运行。系统需要能够处理网络分区导致的节点间通信问题，以确保系统的持续运行。

**问题4**：请解释一下分布式哈希表（Distributed Hash Table，DHT）

分布式哈希表（Distributed Hash Table，简称DHT）是一种分布式系统，它**提供了类似于哈希表的服务**，能够将键（Key）映射到值（Value）。不同于常规的哈希表将所有数据存储在单一节点上，DHT将**数据分散存储在网络中的多个节点**上。每个节点负责存储一部分哈希表的数据。

DHT的设计目标主要是**为了让网络可以自我组织和自我修复**，从而对**节点的加入、离开以及故障**具有良好的适应性。在这种网络中，任何一个节点都可以独立地查询某个键值对，并且可以在网络的任意变化（例如，节点离线或新节点加入）下继续正确高效地工作。


分布式哈希表（DHT）的设计理念主要是为了实现网络的自我组织和自我修复，下面是一些具体的方法：

**节点的加入**：当新节点加入DHT网络时，它会被分配一段哈希空间，并从现有节点那里**接管这部分哈希空间对应的键值对**。新节点的加入可能会引发键值对在网络中的重新分配，以保持系统的均衡性。为了支持新节点的加入，DHT中的每个节点都需要保持一份部分节点信息的路由表，以便将**查询请求转发到正确的节点**。

**节点的离开**：当一个节点离开网络（无论是主动离开还是由于故障导致的离开），它负责的**键值对需要被转移给其他节点**。这个过程通常是通过**数据冗余和复制**实现的，即每个键值对在多个节点上都有存储。因此，当一个节点离开时，其他节点可以接管失效节点的数据。

**节点的故障**：节点的故障可以视为一种极端的节点离开。为了处理这种情况，DHT通常会在多个节点上存储每个键值对的副本，这样即使有节点故障，数据也不会丢失。


**问题5:BASE理论了解吗？**
**答案**：BASE（Basically Available、Soft state、Eventual consistency）是基于CAP理论逐步演化而来的，核心思想是即便不能达到强一致性（Strong consistency），也可以根据应用特点采用适当的方式来达到最终一致性（Eventual consistency）的效果。
Basically Available：出现了不可预知的故障，但还是能用，但是可能会有响应时间上的损失，或者功能上的降级。
Soft State（软状态）：允许系统在多个不同节点的数据副本存在数据延时。
Eventually Consistent（最终一致性）：最终所有副本保持数据一致性。


**问题6:什么是分布式锁？**
**答案**：分布式锁来保证任何时刻只有一个节点可以获取到锁，进而独占资源。


**问题7:有哪些分布式锁的实现方案呢？**
**答案**：分布式锁来保证任何时刻只有一个节点可以获取到锁，进而独占资源。


分布式锁的实现方案主要有以下几种：

**基于数据库的分布式锁**：利用数据库的原子性操作来实现。例如，在MySQL中，我们可以通过创建一个唯一索引字段，加锁的时候，在锁表中增加一条记录即可，由于唯一索引的限制，任何时候只能插入成功一条记录，从而达到锁的效果。释放锁的时候删除记录就行。但是，这种方法可能会对数据库造成较大压力。因此这种方式在高并发、高性能的场景中用的不多。

> **并发量较小**：如果系统的并发量相对较小，数据库的压力可以接受，那么可以使用基于数据库的分布式锁。因为这种方式实现起来相对简单，不需要额外的依赖和组件。

> **业务逻辑简单**：如果业务逻辑相对简单，不需要复杂的锁操作，比如公平性、可重入性等，那么基于数据库的分布式锁可以满足需求。

> **对数据一致性要求较高**：如果对数据一致性要求较高，比如涉及到重要的交易操作等，可以使用基于数据库的分布式锁，因为数据库的ACID特性能保证数据的一致性。

> **系统已经依赖特定数据库**：如果系统已经严重依赖某种数据库，那么在不引入新的组件的情况下，使用数据库实现分布式锁可能是一种选择。


**基于缓存的分布式锁**：例如Redis。Redis提供了一些原子操作命令，如SETNX（Set if Not eXists），可以用来实现分布式锁。Redis的优点是性能高，操作简单。但是，这种方式的锁并不是严格的分布式锁，因为在某些情况下可能会出现锁失效的情况。

> Redis可以用于实现分布式锁，通常使用`SETNX`（如果不存在，则设置）和`EXPIRE`（设置键的过期时间）这两个命令来实现。以下是基本步骤：

完整的Redis分布式锁的实现过程如下：

> **锁的获取**：首先，客户端使用`SETNX`命令尝试设置一个锁。`SETNX`会尝试设置一个键，如果键不存在，那么设置成功并返回1，如果键已经存在，那么设置失败并返回0。客户端可以通过这个返回值来判断是否获取锁成功。

```text
setNx resourceName value
```
> **设置过期时间**：如果客户端成功获取到了锁，那么它应该立刻使用`EXPIRE`命令为这个锁设置一个过期时间。这是为了避免死锁：如果持锁的客户端崩溃，导致它无法正常释放锁，那么这个锁将会因为过期时间到达而自动被删除。
```text
set resourceName value ex 5 nx
```
> **执行业务操作**：在获取到锁之后，客户端可以安全地执行需要同步的业务操作。

> **锁的释放**：当客户端不再需要锁的时候，它可以使用`DEL`命令来删除这个锁。

> 需要注意的是，为了保证整个过程的安全性，你应该在同一客户端中执行上述所有操作。因为Redis是基于单线程模型的，所以在同一个连接中的操作都是顺序执行的，这样可以避免多个客户端同时获取到锁。此外，你还应该对可能的异常情况进行处理，比如在执行业务操作的过程中可能出现的异常，以及客户端与Redis的连接中断等问题。

> Redis 做分布式锁 ，一般生产中都是使用Redission客户端，非常良好地封装了分布式锁的api，而且支持RedLock。


**基于Zookeeper的分布式锁**：Zookeeper是一个开源的分布式协调服务，它提供了一种名为"顺序临时节点"的机制，可以用来实现分布式锁。Zookeeper的这种机制可以保证锁的安全性和效率，因此被广泛用于分布式锁的实现。

ZooKeeper的分布式锁实现主要利用了其**临时顺序节点**（Ephemeral Sequential Nodes）的特性。以下是一个基本的实现过程：

> **锁的创建**：当一个客户端（即节点）试图获取一个锁时，它会在预定义的ZNode（这个ZNode可以被视作是锁,或者说以某个资源为目录）下创建一个临时顺序ZNode。Zookeeper保证所有创建临时顺序ZNode的请求都会被顺序地处理，每个新的ZNode的名称都会附加一个自动增长的数字。

> **锁的获取**：在创建临时顺序ZNode之后，客户端获取预定义ZNode下所有子节点的列表，然后检查自己创建的临时ZNode的序号是否是最小的。如果是最小的，那么客户端就认为它已经成功获取了锁。如果不是最小的，那么客户端就会找到序号比它小的那个ZNode，然后在其上设置监听（Watcher），这样当那个ZNode被删除的时候，客户端会得到通知。

> **锁的释放**：一旦完成了对共享资源的访问，客户端会删除它创建的那个临时ZNode，以释放锁。这时候，Zookeeper会通知监听该ZNode的其他客户端，告诉它们ZNode已经被删除。

> **故障处理**：如果持锁的客户端出现故障或与Zookeeper的连接中断，它创建的临时ZNode会被Zookeeper自动删除，从而使锁被释放。这是因为ZooKeeper中的临时节点（Ephemeral Nodes）的特性决定的。在ZooKeeper中，临时节点的生命周期与创建它们的会话（Session）绑定在一起。也就是说，如果创建临时节点的会话结束（无论是正常结束还是因为超时或其他原因被终止），那么这个临时节点会被ZooKeeper自动删除。

> 当我们使用临时节点来实现分布式锁的时候，如果持锁的客户端出现故障或与ZooKeeper的连接中断，它的会话将会被ZooKeeper结束。这时，该客户端创建的临时节点（代表锁）会被自动删除，从而实现了锁的自动释放。这样，其他等待获取锁的客户端就可以尝试获取锁，进而确保了系统的正常运行。

**基于Chubby或Google Cloud Storage的分布式锁**：这是Google提供的两种分布式锁服务。Chubby是一个小型的分布式锁服务，Google Cloud Storage则提供了一种基于云存储的分布式锁机制。

