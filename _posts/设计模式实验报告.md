# 设计模式实验报告

## 1.项目基本情况

### 『背景』：

随着社会迅速发展下，很多青年人纷纷往城市进行工作，而这些在城市工作的人，也是需要解决住的问题，有很多人通过网上寻找房子，但是往往很难知道房子的真假情况，为了解决这些问题，租房 APP 软件开发应运而生，为用户提供获取符合心意的租房服务。

**用户角度：**

用户可以在线寻找更多的房源：互联网高速发展使得网络信息泛滥，很多人在网上找房子信息，但是当中也会遇到很多问题，现在可以通过 APP 软件帮助用户寻找更多真实的房源信息，用户可以通过位置来寻找房子，也可以搜关键词进行寻找房子，这样可以帮助人们减少更多时间寻找房子

**房东角度：**

房东可以在线发布房源信息：该平台集聚了更多房东发布房源信息，房东通过在线实名认证，通过审核后可以在线发布房源信息。平台会更加情况来推送相关房源给用户，这样有利于用户快速寻找适合的房子。

**APP 角度：**

能够便捷管理房源信息：该平台可以便捷管理房源信息，为用户筛选不符合的房源信息

去除房屋中介化：人们在生活中寻找租房时，有可能会被租房中介坑骗，使用本 APP，则能去除房屋中介化，用户可以直接和一手房东进行对接，方便用户在平台上和一手房东进行沟通交流，十分便捷。

及时更新房源信息：租房 APP 实时的收集每一个城市的房源，及时在后台更新相对应的房源信息，让用户可以快速的查找，同时大大的提高出租率

### 『功能』：

![image-20221127091134393](/home/gongna/.config/Typora/typora-user-images/image-20221127091134393.png)

##### 涵盖的功能包括：

1.注册

2.登陆

3.发布房屋信息

4.修改房屋信息

5.删除房屋信息

6.查询房屋信息

7.根据价格过滤房屋信息

8.根据房屋面积过滤房屋信息

9.对已经完成的房屋出租订单进行评论

10.对其他用户发布的评论进行点赞，取消点赞。

11.用户可以查询自己发布过的所有评论。

### 『使用场景』：

**场景 1：用户想租个房子**。描述：用户小明今年刚刚毕业，想在自己上班的地方附近租一件公寓。但是第一次租房，人生地不熟。害怕被中介骗，于是安装 APP，注册登陆点击附近公寓查询，发现有几个公寓价环境优美、也很便宜。于是选择该房屋，通过联系房主，线下看房，最后成功找到自己心仪的房屋。

**场景 2：用户想看看某个房主发布的信息是否属实，了解房屋的真实环境，以及真实租客体验**。描述：9 点的时候，用户小红在 APP 上看到一则房屋消息，小红觉得很心动，但是小红是个女生，一个人租房，所以格外担心人生安全是否能得到保障。于是点开评论查看其他曾经租过这个房子的租客发布的评价，了解房主是否可靠，真实的租客环境如何。

**场景 3：用户想给某个写的很好的房屋评价点赞**。描述：用户小明浏览了某个房屋下面的用户评价，其中有个评价写的详细，给自己提供了很好的参考，于是对那条评价点赞，这样一来，其他用户也能看到某个房屋下面，点赞量较高的评论，从而对自己的选择提供一个参考。

**场景 4：用户想出租自己闲置的房屋**。描述：用户小亮有几个房屋闲置，希望通过该平台把房子租出去，但是由于没有经验，不知道出租费用如何定价，以及不想被中介收取中介费用，于是打开该 APP，对比自己的房屋信息和其他的房屋信息，定出了一个合理且优惠的价格，并按照平台要求填写出租信息并且提供房屋的产权证明，经过平台审核完毕后，很快便有租客联系想要线下看房，最后，小亮和租客各自都以自己满意价格达成了交易。

**场景 5：用户想修改自己出租信息**。描述：用户小亮有几个房屋闲置，已经通过平台 APP 把房子出租信息发布出去，但是由于时间限制，这个房子也只能出租到明年 3 月，于是小明修改了发布的房屋的出租信息，然后很快房子便被出租出去了。

### 『代码行数』：

![image-20221127103021512](/home/gongna/.config/Typora/typora-user-images/image-20221127103021512.png)

## 2.设计模式

### 『单例模式』：

**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

**解决的问题：**

1. **保证一个类只有一个实例**。 是控制某些共享资源 （在这里是控制对数据库） 的访问权限。

   它的运作方式是这样的： 如果创建了一个对象， 同时过一会儿后决定再创建一个新对象， 此时会获得之前已创建的对象， 而不是一个新对象。

   但是这种方式通过普通构造函数无法实现， 因为构造函数的设计决定了它**必须**总是返回一个新对象。

2. **为该实例提供一个全局访问节点**。 在我的程序中间使用了一写存储重要对象的全局变量 ，它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。

3. **仅在首次请求单例对象时对其进行初始化**。

**解决方案—sync.Once ：**

`sync.Once` 是 Go 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 `init` 函数类似，但有区别。

- init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。
- sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是**线程安全**的。

在多数情况下，`sync.Once` 被用于控制变量的初始化，这个变量的读写满足如下三个条件：

- 当且仅当第一次访问某个变量时，进行初始化（写）；
- 变量初始化过程中，所有读都被阻塞，直到初始化完成；
- 变量仅初始化一次，初始化完成后驻留在内存里。

`sync.Once` 仅提供了一个方法 `Do`，参数 f 是对象初始化函数。

```go
func (o *Once) Do(f func())
```

在这里初始化数据库的时候就调用了这个方法来初始化数据库，这样的好处是：

- 保证变量仅被初始化一次，需要有个标志来判断变量是否已初始化过，若没有则需要初始化。

- 线程安全，支持并发，无疑需要互斥锁来实现

##### Example1-DB 单例

![image-20221127104121325](/home/gongna/.config/Typora/typora-user-images/image-20221127104121325.png)

**UML 解释：**

1. **单例** （DB） 类声明了一个名为 `Get­Instance`获取实例的方法来返回其所属类的一个相同实例。

   单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 `获取实例`方法必须是获取单例对象的唯一方式。

```go
//第一种写法
var DB *gorm.DB
var once sync.Once
// 初始化
func init() {
	var err error
	if DB == nil {
		once.Do(func() {
			fmt.Println("Creating database single instance now.")
			DB, err = gorm.Open(getDBConfig(), &gorm.Config{
				Logger: NewGormLogger(),
			})
			// 处理错误
			if err != nil {
				log.Fatal(err.Error())
			}
			if err != nil {
				log.Fatal("Open database failed",
					zap.String("reason", err.Error()),
					zap.String("detail", "Database connection failed."))
			}
		})

	} else {
		log.Fatal("Warning:connect to the database again",
			zap.String("reason", "Database instance already created."),
			zap.String("detail", "Connect to Database again failed."))
	}
}
// 使用
func GetDBInstance() *gorm.DB {
	return DB
}
```

##### Example2-Logger 单例

![image-20221127104426792](/home/gongna/.config/Typora/typora-user-images/image-20221127104426792.png)

**单例** （GormLogger） 类声明了一个名为 `NewGormLogger`方法来返回其所属类的一个 Logger 实例。但是所有的 Logger 实例的`ZapLoggerd`都是同一个`Logger`实例。

单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 `获取实例`方法必须是获取单例对象的唯一方式。

```go
var Logger *zap.Logger

func init() {
	filename := "./logs/status.log"
	maxSize := 128
	maxBackups := 5
	maxAge := 30
	compress := true
	InitLogger(filename, maxSize, maxBackups, maxAge, compress)
}

```

在 "github.com/ShortTermRental/Backend/log"下使用单例变量

```go
// GormLogger 操作对象，实现 gormlogger.Interface
type GormLogger struct {
	ZapLogger     *zap.Logger
	SlowThreshold time.Duration
}

func NewGormLogger() GormLogger {
	return GormLogger{
		ZapLogger:     logger.Logger,          // 使用全局的 logger.Logger 对象
		SlowThreshold: 200 * time.Millisecond, // 慢查询阈值，单位为千分之一秒
	}
}
```

### 『外观模式』：

**外观模式**是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。

**解决的问题：**

我必须在代码中使用`jwt-go`库生成 token,然后在用户登陆和注册之后，签发给客户端，在之后的请求访问中，客户端只需携带 Token，服务端就可以知道该用户是我们真正的用户。 正常情况下， 我需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。

**解决方案：**

JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种方式，用于在各方之间安全地将信息作为 JSON 对象传输。由于此信息是经过数字签名的，因此可以被验证和信任。可以使用秘密（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对对 JWT 进行签名。

尽管可以对 JWT 进行加密以提供双方之间的保密性，签名的令牌可以验证其中包含的声明的完整性，而加密的令牌则将这些声明隐藏。当使用公钥/私钥对对令牌进行签名时，签名还证明只有持有私钥的一方才是对其进行签名的一方。

我必须在代码中使用`jwt-go`库生成 token,然后在用户登陆和注册之后，签发给客户端，在之后的请求访问中，客户端只需携带 Token，服务端就可以知道该用户是我们真正的用户。 正常情况下， 我需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。在这里我使用一个`JWT`外观类,封装了`jwt-go`库中我需要的功能，然后向外界提供了一个简单的接口。 与直接调用`jwt-go`库相比， `JWT`外观类提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。

如果程序需要与包含好几个功能的复杂库（可以是第三方库，也可以是自己自定义的库）整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便.

**UML 图：**

![image-20221127110855478](/home/gongna/.config/Typora/typora-user-images/image-20221127110855478.png)

**UML 解释：**

1. **外观** （JWT） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。
2. 创建**附加外观** （JWTCustomClaims） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
3. **复杂子系统** （Complex Subsystem） 由数十个不同对象构成。 了解子系统的实现细节， 按照正确顺序初始化对象和为其提供正确格式的数据。子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。
4. **客户端** （Client） 使用外观代替对子系统对象的直接调用。

```go

// JWT 定义一个jwt对象
type JWT struct {

	// 秘钥，用以加密 JWT，读取配置信息 app.key
	SignKey []byte

	// 刷新 Token 的最大过期时间
	MaxRefresh time.Duration
}

func NewJWT() *JWT {
	return &JWT{
		SignKey:    []byte(config.GetString("app.key")),
		MaxRefresh: time.Duration(config.GetInt64("jwt.max_refresh_time")) * time.Minute,
	}
}

// IssueToken 生成  Token，在登录成功时调用
func (jwt *JWT) IssueToken(userID string, userName string) string {

	// 1. 构造用户 claims 信息(负荷)
	expireAtTime := jwt.expireAtTime()
	claims := JWTCustomClaims{
		userID,
		userName,
		expireAtTime,
		jwtpkg.StandardClaims{
			NotBefore: TimenowInTimezone().Unix(),   // 签名生效时间
			IssuedAt:  TimenowInTimezone().Unix(),   // 首次签名时间（后续刷新 Token 不会更新）
			ExpiresAt: expireAtTime,                 // 签名过期时间
			Issuer:    config.GetString("app.name"), // 签名颁发者
		},
	}

	// 2. 根据 claims 生成token对象

	token, err := jwt.createToken(claims)
	if err != nil {
		log.LogIf(err)
		return ""
	}

	return token
}

// expireAtTime 过期时间
func (jwt *JWT) expireAtTime() int64 {
	timenow := TimenowInTimezone()
	var expireTime int64
	if config.GetBool("app.debug") {
		expireTime = config.GetInt64("jwt.debug_expire_time")
	} else {
		expireTime = config.GetInt64("jwt.expire_time")
	}
	expire := time.Duration(expireTime) * time.Minute
	return timenow.Add(expire).Unix()
}

func (jwt *JWT) createToken(claims JWTCustomClaims) (string, error) {

	// 使用HS256算法进行token生成
	token := jwtpkg.NewWithClaims(jwtpkg.SigningMethodHS256, claims)
	return token.SignedString(jwt.SignKey)
}

// ParserToken 解析 Token，中间件中调用
func (jwt *JWT) ParserToken(c *gin.Context) (*JWTCustomClaims, error) {
	//
	tokenString, parseErr := jwt.getTokenFromHeader(c)
	if parseErr != nil {
		return nil, parseErr
	}

	// 1. 调用 jwt 库解析用户传参的 Token
	token, err := jwt.parseTokenString(tokenString)

	// 2. 解析出错
	if err != nil {
		validationErr, ok := err.(*jwtpkg.ValidationError)
		if ok {
			if validationErr.Errors == jwtpkg.ValidationErrorMalformed {
				return nil, ErrTokenMalformed
			} else if validationErr.Errors == jwtpkg.ValidationErrorExpired {
				return nil, ErrTokenExpired
			}
		}
		return nil, ErrTokenInvalid
	}

	// 3. 将 token 中的 claims 信息解析出来和 JWTCustomClaims 数据结构进行校验
	if claims, ok := token.Claims.(*JWTCustomClaims); ok && token.Valid {
		return claims, nil
	}

	return nil, ErrTokenInvalid
}

// getTokenFromHeader 使用 jwtpkg.ParseWithClaims 解析 Token
// Authorization:Bearer xxxxx
func (jwt *JWT) getTokenFromHeader(c *gin.Context) (string, error) {
	authHeader := c.Request.Header.Get("Authorization")

	if authHeader == "" {
		return "", ErrHeaderEmpty
	}
	// 按空格分割
	parts := strings.SplitN(authHeader, " ", 2)
	if !(len(parts) == 2 && parts[0] == "Bearer") {

		return "", ErrHeaderMalformed
	}
	fmt.Println(parts[1])
	return parts[1], nil
}

// parseTokenString 使用 jwtpkg.ParseWithClaims 解析 Token
func (jwt *JWT) parseTokenString(tokenString string) (*jwtpkg.Token, error) {
	return jwtpkg.ParseWithClaims(tokenString, &JWTCustomClaims{}, func(token *jwtpkg.Token) (interface{}, error) {
		return jwt.SignKey, nil
	})
}

```

```go
// JWTCustomClaims 自定义载荷
type JWTCustomClaims struct {
	UserID       string `json:"user_id"`
	UserName     string `json:"user_name"`
	ExpireAtTime int64  `json:"expire_time"`

	// StandardClaims 结构体实现了 Claims 接口继承了  Valid() 方法
	// JWT 规定了7个官方字段，提供使用:
	// - iss (issuer)：发布者
	// - sub (subject)：主题
	// - iat (Issued At)：生成签名的时间
	// - exp (expiration time)：签名过期时间
	// - aud (audience)：观众，相当于接受者
	// - nbf (Not Before)：生效时间
	// - jti (JWT ID)：编号
	jwtpkg.StandardClaims
}

func (jwt *JWTCustomClaims) UserIdToInt() (userId int) {
	return cast.ToInt(jwt.UserID)

}
```

### 『责任链模式』

**责任链模式**是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。

**解决的问题：**

假如你正在开发一个短期出租房屋的系统。 我希望对系统访问进行限制， **只允许认证用户登陆查看可以出租的房屋的信息 **、**只允许认证用户登陆查看可以发布对房屋的评论**、**只允许认证用户点赞其他用户的评论**、 此外， 拥有管理权限的用户也拥有所有访问房屋信息，发布评论等完全访问权限。

这些检查必须依次进行。 只要接收到包含用户凭据的请求， 我的应用程序就要对尝试对进入系统的用户进行认证。 但如果由于用户凭据不正确而导致认证失败， 那就没有必要进行后续检查了。在接下来的几个月里， 我实现了后续的几个检查步骤。

- 因为**直接将原始数据传递给后端的服务存在安全隐患**。 因此我新增了**额外的验证步骤**来清理请求中的数据。
- 又因为系统**无法抵御暴力密码破解方式的攻击**。 为了防范这种情况， 又添加了一个检查步骤来过滤来自同一 IP 地址的重复错误请求。
- 又因为如果包含同样数据的重复请求返回缓存中的结果， 从而就提高系统响应速度。 因此， 我新增了一个检查步骤， 确保只有没有满足条件的缓存结果时请求才能通过并被发送给后端服务。
- 以上的所有逻辑都与我的业务逻辑紧密耦合。

**解决方案：**

因次，我把以上的验证步骤单独的抽离为单独的函数和方法，以中间件的形式，传递给引擎`Engine`，所有请求将先通过这些相同的过滤函数。

中间件 `middleware` 在 `golang` 中也是一个很重要的概念，与 `java` 中拦截器很相似。。Gin 的中间件是通过`Use`方法设置的，它接收一个可变参数，所以我同时可以设置多个中间件。Gin 的中间件其实就是一个`HandlerFunc`,那么只要我自己实现一个`HandlerFunc`，就可以自定义一个自己的中间件。

```go
func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes
```

而且 中间件有个 `Next` 函数，在我定义的众多中间件，会形成一条中间件链，而通过 `Next` 函数来对后面的中间件进行执行。这里其实就是职责链模式的变体，因为它会在每一个处理函数中进行处理，而不是第一个接收到就停止了。

于是我自己定义了一个 `Logger` 日志

**UML 图：**

![image-20221127190603835](/home/gongna/.config/Typora/typora-user-images/image-20221127190603835.png)

**UML 解释：**

1. **处理者** （IRoutes） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。

2. **基础处理者** （RouterGroup） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。

   通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。

3. **具体处理者** （Log） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。

   处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。

4. **客户端** （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。

```go
// IRoutes defines all router handle interface.
type IRoutes interface {
	Use(...HandlerFunc) IRoutes

	Handle(string, string, ...HandlerFunc) IRoutes

}
```

```go
// RouterGroup is used internally to configure router, a RouterGroup is associated with
// a prefix and an array of handlers (middleware).
type RouterGroup struct {
	Handlers HandlersChain
	basePath string
	engine   *Engine
	root     bool
}

var _ IRouter = (*RouterGroup)(nil)

// Use adds middleware to the group, see example code in GitHub.
func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes {
	group.Handlers = append(group.Handlers, middleware...)
	return group.returnObj()
}

func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes {
	if matched := regEnLetter.MatchString(httpMethod); !matched {
		panic("http method " + httpMethod + " is not valid")
	}
	return group.handle(httpMethod, relativePath, handlers)
}
```

```go

type Log struct{}

func (l *Log) Logger() gin.HandlerFunc{
	return Logger()
}

func Logger() gin.HandlerFunc {
	return func(c *gin.Context) {

		// 获取 response 内容
		w := &responseBodyWriter{body: &bytes.Buffer{}, ResponseWriter: c.Writer}
		c.Writer = w

		// 获取请求数据
		// requestBody =ioutil.ReadAll(c.Request.Body)
		var requestBody []byte
		if c.Request.Body != nil {
			// c.Request.Body 是一个 buffer 对象，只能读取一次
			requestBody, _ = ioutil.ReadAll(c.Request.Body)
			// 读取后，重新赋值 c.Request.Body ，以供后续的其他操作
			c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(requestBody))
		}

		// 设置开始时间
		start := time.Now()
		c.Next()

		// 开始记录日志的逻辑
		//cost.MicrosecondsStr转化为string
		cost := time.Since(start)

		responStatus := c.Writer.Status()

		logFields := []zap.Field{
			zap.Int("status", responStatus),
			zap.String("request", c.Request.Method+" "+c.Request.URL.String()),
			zap.String("query", c.Request.URL.RawQuery),
			zap.String("ip", c.ClientIP()),
			zap.String("user-agent", c.Request.UserAgent()),
			zap.String("errors", c.Errors.ByType(gin.ErrorTypePrivate).String()),
			zap.String("time", helpers.MicrosecondsStr(cost)),
		}

		if c.Request.Method == "POST" || c.Request.Method == "PUT" || c.Request.Method == "DELETE" {
			// 请求的内容
			logFields = append(logFields, zap.String("Request Body", string(requestBody)))
			// 响应的内容
			logFields = append(logFields, zap.String("Response Body", w.body.String()))
		}

		if responStatus > 400 && responStatus <= 499 {
			// 除了 StatusBadRequest 以外，warning 提示一下，常见的有 403 404，开发时都要注意
			log.Warn("HTTP Warning "+cast.ToString(responStatus), logFields...)
		} else if responStatus >= 500 && responStatus <= 599 {
			// 除了内部错误，记录 error
			log.Error("HTTP Error "+cast.ToString(responStatus), logFields...)
		} else {
			log.Debug("HTTP Access Log", logFields...)
		}
	}
}
```

然后注册.

```go
//注册全局中间件
func registerGlobalMiddleWare(g *gin.Engine) {
	g.Use(middlewares.Logger())
}
```

### 『建造者模式』：

**生成器模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

**解决的问题：**

该模式会将对象构造过程划分为一组步骤 。 每次创建对象时， 都通过生成器对象执行一系列步骤。 重点在于我无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。在这种情况下， 可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后我就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。在这里，因为 model Comment 有下面几种不同的创建的过程：

- 当用户需要发布一条评论的时候，这个时候，只需要初始化`Comment.UserID` 、`Comment.Content`、`Comment.RoomID` 这三个属性得到 Comment 对象，然后把数据插入数据库就可以。
- 当用户需要查看另外一个用户发布的一条评论的详情的时候，这个时候，只需要初始化`Comment.UserID` 、`Comment.RoomID` 这两个属性得到 Comment 对象，然后拿着这个 Comment 对象去数据库查询这个 Comment 的具体内容是什么，然后返回给客户端就可以。
- 当用户需要查看自己曾经发布过的所有评论的时候，这个时候，只需要初始化`Comment.UserID` 这一个属性得到 Comment 对象，然后拿着这个 Comment 对象去数据库查询用户 ID 为`UserID `的用户发布的所有评论记录，然后返回给客户端`[]Comment`,这样用户就得到了自己曾经发布过的所有评论。
- 当其他用户为某个用户的一条评论点赞的时候，这个时候，只需要只需要初始化`Comment.UserID` 、`Comment.RoomID` 这两个属性得到 Comment 对象，然后拿着这个`Comment `对象去数据库更新用户 ID 为`UserID `，且房屋 ID 为 `RoomID`的记录，然后更新点赞数。

![image-20221127173338334](/home/gongna/.config/Typora/typora-user-images/image-20221127173338334.png)

1. **生成器** （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。
2. **具体生成器** （CommentBuilder） 提供构造过程的不同实现。
3. **产品** （Comment） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。
4. **主管** （Director） 类定义调用构造步骤的顺序， 这样就可以创建和复用特定的产品配置。
5. **客户端** （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 在使用主管类生产产品时每次都可以使用不同的生成器。

```go

type  Director struct{
	Builder IBuilder
}

func (d *Director) Director(builder IBuilder ){
	d.Builder=builder
}

func (d *Director) ChangeBuilder(builder IBuilder ){
	d.Builder=builder
}
func (d *Director) make(rid int , uid int ,content string,kind string){
	if strings.Compare(kind,"create")==0{
		d.Builder.BuilderWithRoomId(rid)
		d.Builder.BuilderWithUserId(uid)
		d.Builder.BuilderWithContent(content)
		return
	}
	if strings.Compare(kind,"find")==0{
		d.Builder.BuilderWithUserId(uid)
		return
	}
	if strings.Compare(kind,"update")==0{
		d.Builder.BuilderWithUserId(uid)
		d.Builder.BuilderWithRoomId(rid)
		return
	}
}

type IBuilder interface {
	Reset()
	BuilderWithRoomId(int)
	BuilderWithUserId(int)
	BuilderWithContent(string)
}

type CommentBuilder struct {
	Comment *Comment
}

func NewCommentBuilder() *CommentBuilder {
	return &CommentBuilder{
		Comment: NewComment(),
	}
}

func (c *CommentBuilder) BuilderWithRoomId(id int) {
	c.Comment.RoomID = id
}

func (c *CommentBuilder) BuilderWithUserId(id int) {
	c.Comment.UserID = id
}

func (c *CommentBuilder) BuilderWithContent(content string) {
	c.Comment.Content = content
}

func (c *CommentBuilder) Getresult() *Comment {
	return c.Comment
}

type Comment struct {
	model.BaseModel

	RoomID  int    `json:"rid" gorm:"column:rid;" binding:"required"`
	UserID  int    `json:"uid" gorm:"column:uid;" binding:"required"`
	Content string `json:"content" gorm:"column:content;" binding:"required"`
	Likes   int    `json:"likes" gorm:"column:likes;" binding:"required"`
} //@name Comment

```
