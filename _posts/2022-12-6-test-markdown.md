---
layout: post
title: 调度器？
subtitle:
tags: [golang]
---

```text
Process-+Thread
        |
        |
        +Thread +Goroutines
                |
                +Goroutines
```

Go 语言的调度器通过使用和 CPU 数量相等的线程：减少线程频繁切换的内存开销，然后在每个线程上面使用开销更低的 Goroutines 来减少操作系统硬件的负载。

单线程调度器 · 0.x
只包含 40 多行代码；
程序中只能存在一个活跃线程，由 G-M 模型组成；

多线程调度器 · 1.0
允许运行多线程的程序；
全局锁导致竞争严重；

任务窃取调度器 · 1.1
引入了处理器 P，构成了目前的 G-M-P 模型；
在处理器 P 的基础上实现了基于工作窃取的调度器；
在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；
时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；

抢占式调度

- 基于协做的抢占式调度器，实现思路是：通过编译器在函数调用的时候插入检查抢占的指令，在函数调用的时候检查当前的 Goroutine 是否发起了抢占请求，实现了基于协作的抢占式调度。Goroutine 可能通过垃圾回收或者循环长时间的占用资源而导致程序暂停。
- 基于信号的抢占式调度器，实现思路是：垃圾回收在扫描栈的时候触发抢占式调度。

单线程调度器
1-获取调度器的全局锁；
2-调用 routime.gosave()保存栈寄存器和程序计数器
3-调用 runtime.nextgandunlock 获取下一个需要运行的 Goroutine 并接锁调度器
4-修改全局 M 上面要执行的 Goroutine
5-runtime.gogo 获取下一个需要运行的 Goroutine

多线程调度器
1-抢占锁
2-引入了 GOMAXPROCS 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数。 保存寄存器和程序计数器
3-获取下一个 Goroutine 并释放锁
4-修改 M 上的 Goroutine
5-然后运行下一个 Goroutine
存在的问题：
调度器和锁是全局的资源，所有的调度状态都是中心化存储，锁竞争的问题严重。
线程之间相互传递可运行的 Goroutine，引入大量的延迟。
每个线程都需要处理内存缓存，导致大量的内存占用。
系统调用频繁阻塞和解除阻塞正在运行的线程，增加了额外的开销。

任务窃取调度器
处理器持有一个可以运行的 Goroutine 组成的环形的运行队列 runq,还反向持有一个线程 M，处理器会从处理器队列中选择队列头的 Goroutine 放在线程上进行执行。
把每一个线程绑定到独立的 CPU，然后这些线程被不同的处理器管理，不同的处理器对任务进行工作窃取实现对任务的再分配。

基于协作的抢占式调度：
1- 编译器在调用函数前插入 runtime.morestack
2- 程序在运行的时候会在垃圾回收时暂停程序，系统监控发现 Goroutine 运行超过 10ms 的时候发起抢占式的请求。
3-真正到了函数发生调用的时候，执行编译器插入的函数，判断 Goroutine 的字段 stackguard0 字段是否为 StackPreempt；如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程；

基于信号的抢占式调度：
垃圾回收和栈扫描的时候

# GMP 总结：

M 是一个系统线程，由操作系统调度器调度
G 是一个 Goroutine 代表一个待执行的任务
P 是一个运行在线程上的本地调度器。

G 是 Go 语言调度器中待执行的任务，只存在在 Go 语言运行时，它是 G 哦语言在用户态提供的线程，
