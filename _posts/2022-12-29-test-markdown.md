---
layout: post
title: Raft算法！！！
subtitle:
tags: [golang]
---

# 1.分布式 Raft 算法

有的服务器因为崩溃变得不可以使用，那么就无法与其他的服务器达成一致，只要超过半数的服务器达成一致就可以了，假设有 N 台服务器，N/2+1 就超过半数，就代表大多数了，参选者需要说服大多数的选民（服务器）投票给他，一旦选举后旧跟随其操作。
在 Raft 中，任何一个服务器都可以扮演一下的角色：

- Leader 领导者 ，处理和客户端的交互，日志复制，一般只有一个 Leader
- Follower:类似选民，完全被动
- Candidate 候选人，类似律师，可以被选为一个新的领导者

Raft 的两个过程：

阶段一**Leader Election**：

1. 任何一个服务器都可以成为一个候选者，向其他的服务器发出选举自己的请求.(当 Follower 没有听到 Leader 的声音。)
2. 其他的服务器同意了，发出 OK（只要候选人的数量达到 N/2+1）候选人还是可以成为 Leader

阶段二：

1.成为领导者的服务器可以向选民们发出指令，所有的更改变成日志条目添加到（所有的系统的更改都要经过领导者。每个更改都作为一个条目添加到节点的日志中，但是日志条目当前未提交，因此不会更新节点的值。）

2.然后领导者等待，直到大多数节点都把更改作为日志条目写入日志。(一旦大多数追随者承认，那么条目就会先被领导者提交，领导者返回响应给客户端，如果 无法被多数承认，因此领导者的日志条目保持未提交状态。)

3.更改的日志条目在领导者提交。

4.领导者通知追随者提交该条目已。

5.集群现在就达到了一致性的状态。

## 1.1 Raft 的领导人选举

Raft 有两个超时设置来控制选举。

### 1.1.1 选举超时

1-选举超时是`追随者`等待成为`候选人`的时间。选举超时随机在 150 毫秒到 300 毫秒之间。
2-每个追随者在选举超时后就成为了候选人‘选举超时后，跟随者成为候选人并开始新的选举任期。
3-为自己投票并且向其他节点请求投票消息。
4-接收节点在这个任期内没有投票，那么将投票给候选人。
5-重置选举超时
6-一旦候选人获得多数票，它就成为领导者
7-领导者按照`心跳超时`指定的时间间隔向其追随者发送附加条目消息，
8-追随者然后响应每个附加条目消息。
9-这个选举任期将一直持续到跟随者停止接收心跳并成为候选人为止。

需要注意的是：
一旦 Leader 崩溃，那么 Follower 就会有一个人成为候选者，发出选举的要求。
整个过程有一个时间的限制，如果
两个选举者同时向大家邀票，那么两个候选者在一段时间内等待以后，再由两个候选者发起邀票，首先发起邀票的候选者得到大多数的票，那么另外一个候选者只能沦为 Follower

### 1.1.2 日志复制

1.假设领导者已经选出，这个时候客户端发出一个增加日志请求的要求，日志是：'sally'

2.领导者要求 Follower 服从他的命令，都将这个新的日志追加到他们各自的日志当中

3.大多数的 Follower 服务器把日志写入磁盘文件确认追加成功，发出`Commited Ok`

4.在下一个心跳 heartbeat 中，Leader 会通知所有 Follwer 更新 commited 项目。

如果发生故障？

LeaderA 和有些 Follower 断开连接，这个时候那些断开连接的 Follower 会重新选举新的 LeaderB ，当故障修复以后，LeaderA 变成 Follower ，那么他在失联阶段任何的 Commit 都不算 Commit ，都回滚，接受新的 Leader 的新的更新。

# 2.Http 和 Https

HTTPS 会对 HTTP 请求和响应进行加密。例如，拦截攻击者只能看到随机字符，而不是信用卡详细信息。
**攻击者只能看到被加密随机的字符**

- Https 主要依靠 TLS（传输层安全）加密来保护连接。
- SSL /TSL 他们都是同样的证书
- TSL 主要是由证书颁发机构 CA 颁发。CA 的作用是成为客户端-服务端关系中受信任的第三方，基本上任何人都可以颁发 TLS 证书，但是浏览器仅支持公共信任的 CA。

## 2.1 前端对数据的加密：MD5 MessageDigest Algorithm 信息摘要算法

前端把密码通过 MD5 进行处理，并把得到的哈希数值发送给后端的服务，服务器由于无法复原密码，就会直接用哈希数值处理用户的请求，第三方获取到这个 H 哈希值后可以绕开前端登陆直接访问服务器，造成安全问题。
真正的加密——使用加密算法 使用混合加密算法——对陈加密和非对称加密

### 2.1.1 对称加密加密

对称加密加密和解秘用的都是同一个密钥，常见的对称加密算法有 DES、3DES、和 AES 等

- 加密和解密双方都需要使用相同的密钥，在传输密钥的过程中无法保证不被截获。
- 用户每次使用对称加密算法的时候，都需要使用其他人不知道的唯一的密钥，这会使得收发信件双方拥有的钥匙数量急剧增加，`密钥管理`成为双发的负担。
- 对称加密算法在分布式网络中间使用比较困难，主要是密钥管理的成本比较高

### 2.1.2 非对称加密

非对称加密：公钥对数据加密，私钥对数据解密。 私钥对数据加密，公钥对数据解密。

甲：生成两个密钥，这两个密钥，一个把数据加密后另外一个可以还原。那么甲决定把两个钥匙中间的一个作为公钥，并把这个公钥给乙方，乙拿着公钥去加密，现在是甲持有两把钥匙，所以，乙用和甲一样的公钥加密完的数据，甲可以拿着私钥去还原数据。

- 加密解密使用不同的钥匙，私钥只有自己有，不需要通过网络进行传输，安全性很高。

所以具体的做法是：

```text
甲（公钥 A、私钥 B） ------ 公钥 A----------------------------> （乙）
甲（公钥 A、私钥 B） <------Key(随机码，且被公钥 A 加密过)-- ------（乙）『公钥 A，随机码 Key』

```

甲的状态：
甲（公钥 A、私钥 B、Key(随机码，且被私钥 B 还原)）
乙的状态：
（乙）（公钥 A，随机码 Key）

然后双方接就可以使用对称加密来安全的传输数据。
HTTP HTTPS
TCP TSL/SSL
IP TCP

HTTPS = HTTP + SSL / TLS。

## 2.2 HTTPS 的整个通信过程的两大阶段

### 2.2.1 证书验证阶段

- 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的 80 端口
- 采用 Https 的服务器必须有一套数字 CA 证书，颁发证书的时候产生一个私钥和公钥，私钥由服务端自己保存，公钥则附带在证书的信息中，可以公开被访问，证书也附带一个电子签名，这个签名用来验证证书的完整性和真实性，防止证书被篡改。
- 服务端口把证书传递给客户端。
- 客户端对证书进行验证并解析，如果证书是不可信机构颁布的、证书已经过期、证书的域名和实际域名不一致，向访问者显示一个警告。
- 证书可靠，那么客户端从浏览器取出服务器的公钥 A
- 客户端生成随机码 KEY，然后用公钥 A 把 KEY 加密后发送给服务器
- 服务器使用私钥解密 KEY。
- 现在客户端和服务端都有 KEY，客户端的 KEY 是客户端自己生成的，服务端的 KEY 是通过解密得到的，并且客户端发给服务端的 KEY 只有服务端可以解密。

## 2.3 HTTPS 和 HTTP 的区别？

- HTTPS=HTTP+(TLS/SSL)
- HTTPs 在 443 端口
- Https 需要先向 CA 申请证书
- HTTP 的响应速度更快
- HTTP 在 80 端口
- HTTP 明文传输

## 2.4 TLS 和 SSL 的区别？

> 为了保证网络通信的安全性，需要对网络上传递的数据进行加密。现在主流的加密方法就是 SSL (Secure Socket Layer)，TLS (Transport Layer Security)。

### 中间人攻击

随着时代的发展，渐渐的有了一类人---C。C 不仅会监听 A 和 B 之间的网络数据，还会拦截 A 和 B 之间的数据，伪造之后再发给 A 或者 B，进而欺骗 A 和 B。C 就是中间人攻击（Man In The Middle Attack）。

为了应对 C 的攻击，A 和 B 开始对自己的数据进行加密。A 和 B 会使用一个共享的密钥，A 在发送数据之前，用这个密钥对数据加密。B 在收到数据之后，用这个密钥对数据解密。因为加密解密用的是同一个密钥，所以这里的加密算法称为对称加密算法。

在 1981 年，DES（Data Encryption Standard）被提出，这是一种对称加密算法。DES 使用一个 56bit 的密钥，来完成数据的加解密。尽管 56bit 看起来有点短，但时间毕竟是在上古时代，56bit 已经够用了。就这样，网络数据的加密开始了。

因为采用了 DES，A 和 B 现在不用担心数据被 C 拦截了。因为就算 C 拦截了，也只能获取加密之后的数据， 没有密钥就没有办法获取原始数据。

但是 A 和 B 之间又有了一个新的问题，他们需要一个共享的 56bit 密钥，并且这个密钥一定要保持私密，否则被 C 拿到了，就没有加密的意义了。首先 AB 不能通过网络来传递密钥，因为**密钥确定以前，所有的网络通信都是不安全**。如果**通过网络传递密钥，密钥有可能被拦截。**。拦截了就没有加密的意义了。**为了安全，A 和 B 只能先见一面，私下商量好密钥**，这样 C 就没办法获取密钥。如果因为任何原因，之前的密钥泄露了，那么 AB 还得再见一面，重新商量一个密钥。

A 和 B 小心的保护着密钥，不让 C 知道。但是道高一尺，魔高一丈。随着技术的发展，计算机速度变得很快，快到可以通过暴力破解的方法来解密经过 DES 加密的信息。不就是 56bit 的密钥吗？C 找了一个好点的计算机，尝试每一个可能的值，这样总能找到一个密钥破解 A 和 B 之间的加密信息。倒不是说 DES 在提出时没有考虑过这种情况，只是在上古时代，计算机没这么快，破解 56bit 的密钥需要的时间非常长。但是现在是中古时代，可能只需要几天就可以破解 56bit 的密钥。

为了应对这个情况，新的协议被提出，例如 triple-DES（最长 168bit 的密钥），AES（最高 256bit 的密钥）。经过这些改进，至少在可以预见的未来，计算机是没有办法在有限的时间内，暴力破解这个长度的密钥。所以，在中古时代，将对称加密算法的密钥长度变长，来应对中间人攻击。但是 A 和 B 还是需要见面商量一个密钥。

时间到了现代。网络通信变得十分发达，A 不只与 B 通信，还同时还跟其他 10000 个人进行网络通信。A 不可能每个人都跑去跟他们见个面，商量一个密钥。

所以一种新的加密算法被提出，这就是非对称加密算法。非对称加密使用两个密钥，一个是 public key，一个是 private key。通过一个特殊的数学算法，使得数据的加密和解密使用不同的密钥。因为用的是不同的密钥，所以称为非对称加密。但是,非对称加密算法里面的 public key 和 private key 在数学上是相关的，这样才能用一个加密，用另一个解密。但是,虽然相关,但是不可能凭借公钥来推算出私钥.**公钥+私钥甲民**.非对称加密最著名的是 RSA 算法.

> 因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。客户端向服务端索取公钥匙,然后用公钥加密数据,然后把数据发给服务器.

非对称加密的好处在于，现在**A 可以保留 private key**,通过**网络传递 public key**.就算 public key 被 C 拦截了，因为没有 private key，C 还是没有办法完成信息的破解。既然**不怕 C 知道 public key**，**也不怕 C 通过公钥算出私钥**.那现在 A 和 B 不用再见面商量密钥，直接通过网络传递 public key 就行。

### 2.4.1 SSL（Secure Socket Layer）

- SSL 介于 HTTP 和 TCP 层之间
- 为 Netspace 所研发，用来保障 INTERNET 上数据传输的安全，利用数据加密技术。确保数据在网络传输的过程中间不会被窃取。用于 WEB 浏览器和服务器之间的身份认证和加密传输。
- SSL 分为两层= SSL 记录协议（建立在 TCP 之上、为高层的数据提供数据封装、压缩、加密）+SSL 握手协议（建立在 SSL 记录协议之上，用来在实际的数据开始传输之前，通讯双方的身份验证、协商加密算法、交换加密密钥等等）
  **客户端和服务端身份验证（确保数据发送到正确的客户端和服务端）、协商加密算法（加密数据，防止数据中途被盗取）、交换加密密钥**

### 2.4.2 TLS（Transport Layer Security）

- TLS 是 SSL 的后续版，写入流 RFC
- TLS = TLS （记录协议）+TLS (握手协议)

TLS 有两层： 一层是 HandShark Protocol 另外一层是 Record Protocol 。
HandShark 通信双方利用它来安全的协商出一份密钥。具体过程是：**客户端告知服务端，自己支持哪些加密算法，客户端把自己本地支持的加密套件(Cipher Suite)传送给服务端，客户端还要自己随机产生一个随机数字。**

Record Protocol 则定义了传输的格式。
非对称加密用来密钥交换，双方通过公钥算法协商出来一份密钥，在 TLS 协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。对称加密用来通信，当然，为了保证数据的完整性，在加密前要先经过 HMAC 的处理。

综合所述：客户端需要给服务端提供的信息有：

- 自己支持的加密算法，比如 RSA 公钥加密。以及（Cipher Suite）加密套件的列表传输给服务端。
- 客户端产生的随机数。
- 支持的压缩方法
- TLS 版本

服务端收到客户端的信息之后需要给客户端返回什么信息？

- CA 证书（对服务端的一种认证）CA 是专门的数字认证机构
- CA 证书里面有一个 电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
- CA 证书里面还有一个有效期限。
- 此外对于非常重要的保密数据，服务端对客户端进行验证，具体做法是：服务端向客户端发出一个 Cerficate Request 消息，要求客户端发送证书对客户端的合法性进行验证。
- 跟客户端一样，服务端也需要产生一个随机数发送给客户端。客户端和服务端都需要这两个随机数来产生一个 Master Secret.

综合所述：服务端需要给客户端回应的信息应该包含以下内容：

- 确认服务端使用的加密通信协议，比如 TLS 版本
- 一个服务端产生的随机数，稍后用于生成“对话密钥”
- 确认使用的加密方法：RSA 公钥加密。
- 服务器证书

#### CA

现实中，通过 CA（Certificate Authority）来保证 public key 的真实性。CA 也是基于非对称加密算法来工作。有了 CA，B 会先把自己的 public key（和一些其他信息）交给 CA。CA 用自己的 private key 加密这些数据，加密完的数据称为 B 的数字证书。现在 B 要向 A 传递 public key，B 传递的是 CA 加密之后的数字证书。A 收到以后，会通过 CA 发布的 CA 证书（包含了 CA 的 public key），来解密 B 的数字证书，从而获得 B 的 public key。

具体过程：

- B 把自己的 public key 和其他信息发送给 CA
- CA 用自己的 private key 加密这些信息，加密完 A 的信息被称为数字证书。
- CA 把数字证书给 B
- B 把 CA 给自己的数字证书发给 A
- A 收到以后通过 CA 发布的证书（包含了 CA 的 public key）解密 B 的数字证书，从而获得 B 的 public key。

CA 的大杀器就是，CA 把自己的 CA 证书集成在了浏览器和操作系统里面。A 拿到浏览器或者操作系统的时候，已经有了 CA 证书，没有必要通过网络获取，那自然也不存在劫持的问题。

### 2.4.3 AES(Advanced Encryption Standard)

AES(Advanced Encryption Standard)，全称：高级加密标准，是一种最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。
明文 P：没有经过加密的数据。

密钥 K：
用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取机密数据。

AES 加密函数:
AES 解密函数:

设 AES 解密函数为 D，则 P = D(K, C),其中 C 为密文，K 为密钥，P 为明文。也就是说，把密文 C 和密钥 K 作为解密函数的参数输入，则解密函数会输出明文 P。

### 2.4.4 CA/非对称加密

一种新的加密算法被提出，这就是非对称加密算法。非对称加密使用两个密钥，一个是 public key，一个是 private key。通过一个特殊的数学算法，使得数据的加密和解密使用不同的密钥。因为用的是不同的密钥，所以称为非对称加密。非对称加密最著名的是 RSA 算法.

非对称加密算法里面的 public key 和 private key 在数学上是相关的，这样才能用一个加密，用另一个解密。不过，尽管是相关的，但以现有的数学算法，又没有办法从一个密钥，算出另一个密钥。

公钥和私钥。如果公钥用于加密，那么相关的私钥用于解密。如果私钥用于加密，那么相关的公钥用于解密。

非对称加密工作流程中的两个参与者是发送者和接收者。每个都有自己的一对公钥和私钥。首先，发送方获得接收方的公钥。接下来:

- 发送方获得接收方的公钥.
- 发送方使用接收方的公钥对数据数据进行加密=密文,然后发送者把密文发给接收方,接收方用自己的私钥匙进行解密.
- 对纯文本消息进行加密。这将创建密文。密文被发送给接收者，接收者用他们的私钥对其进行解密，将其返回为清晰易读的明文。
- 每个发送者都有接收者的公钥。

##### 非对称密码学的例子有哪些？

RSA 算法——最广泛使用的非对称算法——嵌入在 SSL/TLS 中，用于在计算机网络上提供安全通信。RSA 的安全性源自对作为两个大质数乘积的大整数进行因式分解的计算难度。

将两个大质数相乘很容易，但从乘积中确定原始数字（因式分解）却很困难，这构成了公钥加密安全性的基础。分解两个足够大的素数的乘积所花费的时间超出了大多数攻击者的能力。

RSA 密钥通常为 1024 或 2048 位长，但专家认为 1024 位密钥很快就会被破解，这就是为什么政府和行业正在转向 2048 位的最小密钥长度。

椭圆曲线密码术(ECC) 作为 RSA 的替代方案受到许多安全专家的青睐。ECC 是一种基于椭圆曲线理论的公钥加密技术。它可以通过椭圆曲线方程的性质创建更快、更小和更高效的密码密钥。

要破解 ECC，攻击者必须计算椭圆曲线离散对数，这比因式分解要难得多。因此，ECC 密钥大小可以比 RSA 要求的密钥大小小得多，同时仍以较低的计算能力和电池资源使用提供同等的安全性。

##### 非对称密码学的使用

对称密码学也可以应用于许多用户可能需要加密和解密消息的系统，包括：

- 加密的电子邮件。公钥可用于加密消息，私钥可用于解密消息。
- SSL/TLS。在网站和浏览器之间建立加密链接也利用了非对称加密。
- 加密货币。 比特币和其他加密货币依赖于非对称密码学。用户拥有每个人都可以看到的公钥和保密的私钥。比特币使用加密算法来确保只有合法所有者才能使用这些资金。

### 2.4.5 TLS 和 SSL 提供的服务有：

- **身份验证**
- **协商加密算法**
- **传输加密密钥**

### 2.4.6 TLS 和 SSL 的区别：

- 报文鉴别码：SSL 和 TLS 的 MAC 算法。TLS 的 MAC 算法使用的是：连接运算，HMAC 使用的是异或运算
- TLS 支持 SSL 的所有的报警代码
- TLS 的主要目标是使得 SSL 更加安全，增强了更安全的 MAC 算法、更严密的警报

### 2.4.7 总结：

SSL 在 TCP 建立连接之后，发出一个`ClientHello`来进行握手，这个消息里面包含了自己可实现的算法列表和其他需要的信息，服务段回应一个`ServerHello`,在这个里面去诶的嗯这次通信所需要的算法，然后发过去证书（里面包含了身份和自己的公钥），Client 在收到这个消息后会生成一个秘密消息，用 SSL 服务器的公钥加密后传过去，SSL 服务器端用自己的私钥解密后，会话密钥协商成功，双方可以用同一份会话密钥来通信了。
