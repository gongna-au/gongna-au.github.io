---
layout: post
title: Raft算法！！！
subtitle:
tags: [golang]
---

# 1.分布式 Raft 算法

有的服务器因为崩溃变得不可以使用，那么就无法与其他的服务器达成一致，只要超过半数的服务器达成一致就可以了，假设有 N 台服务器，N/2+1 就超过半数，就代表大多数了，参选者需要说服大多数的选民（服务器）投票给他，一旦选举后旧跟随其操作。
在 Raft 中，任何一个服务器都可以扮演一下的角色：

- Leader 领导者 ，处理和客户端的交互，日志复制，一般只有一个 Leader
- Follower:类似选民，完全被动
- Candidate 候选人，类似律师，可以被选为一个新的领导者

Raft 的两个过程：

阶段一**Leader Election**：

1. 任何一个服务器都可以成为一个候选者，向其他的服务器发出选举自己的请求.(当 Follower 没有听到 Leader 的声音。)
2. 其他的服务器同意了，发出 OK（只要候选人的数量达到 N/2+1）候选人还是可以成为 Leader

阶段二：

1.成为领导者的服务器可以向选民们发出指令，所有的更改变成日志条目添加到（所有的系统的更改都要经过领导者。每个更改都作为一个条目添加到节点的日志中，但是日志条目当前未提交，因此不会更新节点的值。）

2.然后领导者等待，直到大多数节点都把更改作为日志条目写入日志。(一旦大多数追随者承认，那么条目就会先被领导者提交，领导者返回响应给客户端，如果 无法被多数承认，因此领导者的日志条目保持未提交状态。)

3.更改的日志条目在领导者提交。

4.领导者通知追随者提交该条目已。

5.集群现在就达到了一致性的状态。

## 1.1 Raft 的领导人选举

Raft 有两个超时设置来控制选举。

### 1.1.1 选举超时

1-选举超时是`追随者`等待成为`候选人`的时间。选举超时随机在 150 毫秒到 300 毫秒之间。
2-每个追随者在选举超时后就成为了候选人‘选举超时后，跟随者成为候选人并开始新的选举任期。
3-为自己投票并且向其他节点请求投票消息。
4-接收节点在这个任期内没有投票，那么将投票给候选人。
5-重置选举超时
6-一旦候选人获得多数票，它就成为领导者
7-领导者按照`心跳超时`指定的时间间隔向其追随者发送附加条目消息，
8-追随者然后响应每个附加条目消息。
9-这个选举任期将一直持续到跟随者停止接收心跳并成为候选人为止。

需要注意的是：
一旦 Leader 崩溃，那么 Follower 就会有一个人成为候选者，发出选举的要求。
整个过程有一个时间的限制，如果
两个选举者同时向大家邀票，那么两个候选者在一段时间内等待以后，再由两个候选者发起邀票，首先发起邀票的候选者得到大多数的票，那么另外一个候选者只能沦为 Follower

### 1.1.2 日志复制

1.假设领导者已经选出，这个时候客户端发出一个增加日志请求的要求，日志是：'sally'

2.领导者要求 Follower 服从他的命令，都将这个新的日志追加到他们各自的日志当中

3.大多数的 Follower 服务器把日志写入磁盘文件确认追加成功，发出`Commited Ok`

4.在下一个心跳 heartbeat 中，Leader 会通知所有 Follwer 更新 commited 项目。

如果发生故障？

LeaderA 和有些 Follower 断开连接，这个时候那些断开连接的 Follower 会重新选举新的 LeaderB ，当故障修复以后，LeaderA 变成 Follower ，那么他在失联阶段任何的 Commit 都不算 Commit ，都回滚，接受新的 Leader 的新的更新。

# 2.Http 和 Https

HTTPS 会对 HTTP 请求和响应进行加密。例如，拦截攻击者只能看到随机字符，而不是信用卡详细信息。
**攻击者只能看到被加密随机的字符**

- Https 主要依靠 TLS（传输层安全）加密来保护连接。
- SSL /TSL 他们都是同样的证书
- TSL 主要是由证书颁发机构 CA 颁发。CA 的作用是成为客户端-服务端关系中受信任的第三方，基本上任何人都可以颁发 TLS 证书，但是浏览器仅支持公共信任的 CA。

## 2.1 前端对数据的加密：MD5 MessageDigest Algorithm 信息摘要算法

前端把密码通过 MD5 进行处理，并把得到的哈希数值发送给后端的服务，服务器由于无法复原密码，就会直接用哈希数值处理用户的请求，第三方获取到这个 H 哈希值后可以绕开前端登陆直接访问服务器，造成安全问题。
真正的加密——使用加密算法 使用混合加密算法——对陈加密和非对称加密

### 2.1.1 对称加密加密

对称加密加密和解秘用的都是同一个密钥，常见的对称加密算法有 DES、3DES、和 AES 等

- 加密和解密双方都需要使用相同的密钥，在传输密钥的过程中无法保证不被截获。
- 用户每次使用对称加密算法的时候，都需要使用其他人不知道的唯一的密钥，这会使得收发信件双方拥有的钥匙数量急剧增加，`密钥管理`成为双发的负担。
- 对称加密算法在分布式网络中间使用比较困难，主要是密钥管理的成本比较高

### 2.1.2 非对称加密

非对称加密：公钥对数据加密，私钥对数据解密。 私钥对数据加密，公钥对数据解密。

甲：生成两个密钥，这两个密钥，一个把数据加密后另外一个可以还原。那么甲决定把两个钥匙中间的一个作为公钥，并把这个公钥给乙方，乙拿着公钥去加密，现在是甲持有两把钥匙，所以，乙用和甲一样的公钥加密完的数据，甲可以拿着私钥去还原数据。

- 加密解密使用不同的钥匙，私钥只有自己有，不需要通过网络进行传输，安全性很高。

所以具体的做法是：

```text
甲（公钥 A、私钥 B） ------ 公钥 A----------------------------> （乙）
甲（公钥 A、私钥 B） <------Key(随机码，且被公钥 A 加密过)-- ------（乙）『公钥 A，随机码 Key』

```

甲的状态：
甲（公钥 A、私钥 B、Key(随机码，且被私钥 B 还原)）
乙的状态：
（乙）（公钥 A，随机码 Key）

然后双方接就可以使用对称加密来安全的传输数据。
HTTP HTTPS
TCP TSL/SSL
IP TCP

HTTPS = HTTP + SSL / TLS。

## 2.2 HTTPS 的整个通信过程的两大阶段

### 2.2.1 证书验证阶段

- 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的 80 端口
- 采用 Https 的服务器必须有一套数字 CA 证书，颁发证书的时候产生一个私钥和公钥，私钥由服务端自己保存，公钥则附带在证书的信息中，可以公开被访问，证书也附带一个电子签名，这个签名用来验证证书的完整性和真实性，防止证书被篡改。
- 服务端口把证书传递给客户端。
- 客户端对证书进行验证并解析，如果证书是不可信机构颁布的、证书已经过期、证书的域名和实际域名不一致，向访问者显示一个警告。
- 证书可靠，那么客户端从浏览器取出服务器的公钥 A
- 客户端生成随机码 KEY，然后用公钥 A 把 KEY 加密后发送给服务器
- 服务器使用私钥解密 KEY。
- 现在客户端和服务端都有 KEY，客户端的 KEY 是客户端自己生成的，服务端的 KEY 是通过解密得到的，并且客户端发给服务端的 KEY 只有服务端可以解密。

## 2.3HTTPS 和 HTTP 的区别？

- HTTPS=HTTP+(TLS/SSL)
- HTTPs 在 443 端口
- Https 需要先向 CA 申请证书
- HTTP 的响应速度更快
- HTTP 在 80 端口

# 3.TLS 和 SSL 的区别？

## 3.1 SSL（Secure Socket Layer）

- SSL 介于 HTTP 和 TCP 层之间
- 为 Netspace 所研发，用来保障 INTERNET 上数据传输的安全，利用数据加密技术。确保数据在网络传输的过程中间不会被窃取。用于 WEB 浏览器和服务器之间的身份认证和加密传输。
- SSL 分为两层= SSL 记录协议（建立在 TCP 之上、为高层的数据提供数据封装、压缩、加密）+SSL 握手协议（建立在 SSL 记录协议之上，用来在实际的数据开始传输之前，通讯双方的身份验证、协商加密算法、交换加密密钥等等）
- **客户端和服务端身份验证（确保数据发送到正确的客户端和服务端）、协商加密算法（加密数据，防止数据中途被盗取）、交换加密密钥**
-

## 3.2 TLS（Transport Layer Security）

- TLS 是 SSL 的后续版，写入流 RFC
- TLS = TLS （记录协议）+TLS (握手协议)

## 3.3 TLS 和 SSL 提供的服务有：

- **身份验证**
- **协商加密算法**
- **传输加密密钥**

## 3.5 TLS 和 SSL 的区别：

- 报文鉴别码：SSL 和 TLS 的 MAC 算法。TLS 的 MAC 算法使用的是：连接运算，HMAC 使用的是异或运算
- TLS 支持 SSL 的所有的报警代码
- TLS 的主要目标是使得 SSL 更加安全，增强了更安全的 MAC 算法、更严密的警报

## 3.5 总结：

SSL 在 TCP 建立连接之后，发出一个`ClientHello`来进行握手，这个消息里面包含了自己可实现的算法列表和其他需要的信息，服务段回应一个`ServerHello`,在这个里面去诶的嗯这次通信所需要的算法，然后发过去证书（里面包含了身份和自己的公钥），Client 在收到这个消息后会生成一个秘密消息，用 SSL 服务器的公钥加密后传过去，SSL 服务器端用自己的私钥解密后，会话密钥协商成功，双方可以用同一份会话密钥来通信了。
