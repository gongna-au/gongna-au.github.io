---
layout: post
title: 软件设计——中级
subtitle:
tags: [软件设计]
comments: true
---

1.立即寻址最快，寄存器寻址次之，直接寻址最慢。
立即寻址将操作数直接嵌入到指令中，因此可以立即访问而不需要额外的内存访问。寄存器寻址涉及将操作数存储在寄存器中，这需要访问寄存器文件，但仍然比直接寻址要快。直接寻址需要额外的内存访问来检索操作数，使其成为三种寻址模式中最慢的一种。

2.PCI总线和SCSI总线
功能不同：PCI是一种系统总线，用于在计算机的各个部件之间传输数据；而SCSI是一种外围设备接口，用于连接和控制存储设备、打印机和其他辅助设备。

PCI总线是并行内总线， SCSI 总线是串行内总线

3.DMA/程序中断

DMA是是指直接内存访问（Direct Memory Access），是一种计算机数据传输技术。它可以在不占用CPU时间的情况下，允许外设（如网卡、声卡、磁盘控制器等）直接访问主存储器中的数据，从而实现高速数据传输。

硬件中断：是指计算机硬件设备向CPU发出的中断信号，例如I/O操作完成、计时器超时等硬件事件。当发生硬件中断时，CPU会停止当前的程序执行，切换到处理该中断的程序，在处理完成后再返回原来的程序。

软件中断：是指通过软件调用专门的中断指令来实现的程序中断。软件中断也被称为“系统调用”，是用户程序获取操作系统功能的主要方式，例如打开文件、读写数据等。

异常：也被称为“陷阱”，是指在程序运行过程中发生了一些不可预知的情况，例如除零错误、访问非法内存地址等。当发生异常时，CPU会停止当前进程的执行，切换到操作系统内核态处理程序来处理异常，处理完成后再返回进程，进程继续执行。

系统调用：是指用户进程运行期间主动进行的一种中断方式，它把控制权交给了操作系统内核。用户进程可以通过系统调用请求操作系统提供服务，例如创建、删除、打开和关闭文件等。

DMA方式可以减轻CPU负担，但是在开始和结束数据传输时，CPU仍然需要进行一定的配置、控制、管理等操作。

DMA方式允许外围设备直接与内存进行数据交换，不需要CPU参与，所以传输速度更快。

4.中断向量提供（ 中断服务程序入口地址）。

5.SRAM

**静态随机存取存储器**，是一种半导体存储器。与**需要定期刷新以保持数据完整性的动态随机存取存储器（DRAM）**不同（使用电容器来存储数据，因此需要定期刷新以避免电容器失去其电荷），它使用锁存电路来存储每个位。 SRAM 比 DRAM 更快、更可靠，但成本更高，存储密度更低。 它通常用于需要快速访问数据的应用程序，例如CPU和微控制器中的**高速缓存存储器**SRAM的数据会在断电后丢失,DRAM需要定期刷新才能保持数据。一般来说,SRAM用于CPU的缓存,DRAM用于主存。

```
            SRAM  DRAM
            静态   动态
存储时间：    无限长 几毫秒
速度：         快     慢
成本：         高     低
存储密度       低     高
用途         CPU缓存 主存

```

6.高速缓存存储器（Cache Memory）

是计算机中的一种特殊存储设备，它用于提高计算机处理速度。它通常位于**CPU和RAM**之间，作为CPU读取和写入数据时的一个缓冲区。

7.DRAM

是动态随机存储器（Dynamic Random Access Memory）的缩写。它是一种常用的计算机内存，用来存储正在运行的程序和数据。

8.FLASH

Flash 存储器采用了一种称为闪存的技术，通过在微小的晶体管上存储电荷来表示数字信息。当需要读取存储在 Flash 存储器中的数据时，控制电路将读取的请求发送到存储器芯片，并将数据发送回计算机或其他设备。与 DRAM 不同，Flash 存储器不需要定期刷新，因此可以实现长期数据存储。

由于其快速读取速度和较低的功耗，Flash 存储器已经成为许多电子产品不可或缺的组成部分，如USB闪存驱动器，闪存卡和SSD硬盘驱动器等，这些产品已经替代了早期使用的磁带式和软盘式的存储介质。

9.EEPROM

EEPROM是一种可擦写可编程只读存储器（Electrically Erasable Programmable Read-Only Memory）。它是一种用于存储数据的非易失性存储器，可以在电源关闭时保持存储的数据。EEPROM的特点是可以对其中的数据进行单独的、逐字节的修改，并且这些修改是非破坏性的，也就是说，即使修改了其中的某个字节，其他字节的数据仍然会被保留。EEPROM可以使用电气信号来擦除和编程内部单元，因此不需要物理上移动或更换芯片来实现操作。EEPROM广泛应用于存储小量数据的场景，如记录系统配置信息、校准数据等。由于EEPROM擦写次数有限，所以需要注意合理使用和管理。


10.补码转换为原码。
我们假设已知一个8位二进制补码的值为11111010，现在要将它转换为原码：
11111010   -10000110 除了符号位，按位取反+1 原码加负号。

11.部署防火墙/安装并及时升级防病毒软件/部署入侵检测系统
部署防火墙有助于保护计算机**网络免受恶意攻击**和**未经授权的访问**
安装并及时升级防病毒软件：安装并及时升级防病毒软件是可以有效防治计算机病毒的策略。防病毒软件可以通过监控系统中出现的病毒、木马等恶意软件进行实时监控和处理，以保护计算机系统的安全。
部署入侵检测系统：部署入侵检测系统可以帮助企业监控其计算机网络系统中的安全事件，并及时发现和响应入侵威胁。

12.AES/RSA/MD5/SHA-1

A.公钥加密    B.流密码    C.分组加密    D.消息摘要

AES是一种分组加密算法：其加密过程中将明文数据分成固定长度的数据块进行加密。

RSA：公钥加密：RSA算法基于质因数分解难题，即将一个大整数分解为两个质数的乘积。非对称加密

MD5/SHA-1/SHA-256 消息摘要算法：任意长的消息输入输出到固定长度。

流密码：对称加密，基于密钥生成的伪随机比特序列。

13.IGMP/SSH/Telnet/RFB
IGMP:IP网路上实现对多组播加入，离开，查询
SSH：加密网络协议，用来文件传输或者远程登录。
Telnet：网络协议，用来远程登录，文件传输
RFB：远程桌面控制协议

14.包过滤防火墙对（ 网络层）的数据报文进行检查。

网络层负责：IP地址和路由选择。

15.防火墙通常分为内网、外网和DMZ三个区域，按照受保护程度，从低到高正确的排列次序为（ ）
答：按照受保护程度，从低到高的排列次序为：外网、DMZ、内网。外网是互联网，它是最不受保护的区域，因为它可以随意被任何人访问。DMZ（Demilitarized Zone）区域通常是指介于内外网之间的一层网络，用于存放Web服务器、邮件服务器等对外提供服务的应用程序。DMZ比外网受保护，但比内网不受保护。最后是内网，它包含公司网络中最重要和最敏感的资源，如数据库服务器、文件服务器等。因此，内网需要最高级别的安全保护。

16.是构成我国保护计算机软件著作权的两个基本法律文件。

A.《计算机软件保护条例》和《软件法》

B.《中华人民共和国著作权法》和《软件法》

C.《中华人民共和国著作权法》和《计算机软件保护条例》

D.《中华人民共和国版权法》和《中华人民共和国著作权法》

C 

17.增量模型

增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。此外，它还具有以下优点：第一个可交付版本所需要的成本和时间很少；开发由增量表示的小系统所承担的风险不大：由于很快发布了第一个版本，因此可以减少用户需求的变更：运行增量投资，即在项目开始时，可以仅对一个或两个增量进行投资。增量模型有以下不足之处：如果没有对用户变更的要求进行规划，那么产生的初始量可能会造成后来增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力。

18.敏捷统一过程(AUP) 的叙述
- 在大型任务上连续
- 在小型活动上迭代
- 每一个不同的系统都需要一套不同的策略、约定和方法论
  
敏捷统一过程（Agile Unified Process，AUP）是一个轻量级的、面向对象的软件开发方法，相较于传统的UP方法，它更加灵活、简化和具有迭代方式。在AUP中，虽然仍然包括初始、精化、构建和转换这四个阶段，但是每个阶段都是连续的迭代，并非经典的UP方法中那样分成固定的几个阶段。


19.极限编程（XP）/水晶法（Crystal）/并列争球法（Scrum）/自适应软件开发（ASD

极限编程（XP）强调团队合作、快速反馈和频繁交付等原则。它涉及到持续集成、测试驱动开发、重构和简单设计等实践。

水晶法（Crystal）是由Alistair Cockburn提出的一组方法论。它包括多种不同规模和复杂度的"水晶"，每种水晶都有其对应的开发方法和过程。

并列争球法（Scrum）是由Ken Schwaber 和Jeff Sutherland提出的一种增量式、迭代式软件开发方法。它强调团队合作、产品所有者驱动、时间盒和可视化等概念。

自适应软件开发（ASD）是一种根据项目需要自适应调整的软件开发方法。在ASD中，开发人员需要灵活地选择和使用各种技术和工具，同时也需要关注项目的变化和风险等因素。

20.硬盘的格式化容量
```
假设某硬盘由 5 个盘片构成（共有 8 个记录面），盘面有效记录区域的外直径为 30cm，内直径为 10cm，记录位密度为 250 位/mm，磁道密度为 16 道/mm，每磁道分 16 个扇区，每扇区 512字节，则该硬盘的格式化容量约为 （ ） MB

8（30-10）*10*16*16*512 /(2*1024*1024)
```
21.虚拟存储器/高速存储器/相联存储器/随机访问存储器
虚拟存储器：将不长用的数据暂时保存到磁盘等外部存储设备上，更具需求重新读区到内存。
高速存储器：速度较快的内存和缓存 Cache/SRAM
随机访问存储器： RAM/SARM/DRAM，可随机访问任意单元的存储设备。
相联存储器：使用类似哈希表的方式实现数据的存储和检索。相联存储器主要由两个部分组成，一个是存储数据的内容部分，另一个是用于比较查找的标签部分。在进行数据检索时，系统会将待查找数据的标签与所有存储数据的标签进行比较，如果匹配成功，则返回相应数据的内容；否则返回未找到的错误信息。

22.负数的补码和移码
```
原码
10000011
补码： 11111100+1= 11111101
移码：
11111100

```

23.-0的原码
```
原码：1
补码：1
移码：0
X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101，[X]移=01010101
原码:1101011
反码:1010100
补码:1010101
移码:0010101
```

24.某指令流水线由5段组成，第1、3、5段所需时间为Δt，第2、4段所需时间分别为3Δt、2Δt，如下图所示，那么连续输入n条指令时的吞吐率（单位时间内执行的指令个数）TP为（）
```
TP=指令总数÷执行这些指令所需要的总时间。执行这些指令所需要的总时间=（Δt+3Δt+Δt+2Δt+Δt）+3（n-1)Δt
```

25.漏洞扫描系统
自动化检测计算机系统、应用程序或网络中的漏洞的软件工具。这些漏洞可以用来攻击计算机系统，从而破坏、盗取或损害数据和系统。漏洞扫描器使用各种技术来识别和利用常见的安全漏洞，例如密码弱点、SQL注入、跨站点脚本等。

26.反编译 反汇编 交叉编译
编译是将高级语言源程序翻译成机器语言程序（汇编形式或机器代码形式），反编译是编译的逆过程。反编译通常不能把可执行文件还原成高级语言源代码，只能转换成功能上等价的汇编程序。

反汇编 (Disassembly)：是将机器语言指令转换为汇编语言指令的过程。反汇编的主要目的是获取已编译程序的汇编代码，以便分析和理解程序的操作方式。

交叉编译 (Cross Compilation)：是指在一台计算机上进行的编译过程，生成运行在不同体系结构计算机或者操作系统上的二进制文件。例如，在 Windows 上编译 Linux 可执行文件就属于交叉编译。

27.电梯调度
```
https://blog.csdn.net/m0_58153897/article/details/127610506
```

28.设系统中有 R 类资源 m 个，现有 n 个进程互斥使用。若每个进程对 R 资源的最大需求 为 w发生死锁的情况。

```
轮流给每个进程分配资源，如果存在资源被分配完，但是没有一个进程被满足，那么发生死锁。
```

29.`某文件系统采用索引节点管理，其磁盘索引块和磁盘数据块大小均为1KB字节且每个文件索引节点有8个地址项iaddr[0]~iaddr[7]，每个地址项大小为4字节，其中iaddr[0]~iaddr[4]采用直接地址索引，iaddr[5]和iaddr[6]采用一级间接地址索引，iaddr[7] 采用二级间接地址索引。若用户要访问文件userA中逻辑块号为4和5的信息，则系统应分别采用( )， 该文件系统可表示的单个文件最大长度是( )KB。`

```
0-4为直接索引，逻辑块0-4
1KB/4B= 1024B/4B=256
5 可以指256个索引块
6 可以指256个索引块
7 可以指256*256=65535个
4+256*2+65535=66053
```

30.RUP：初始——细化——构建——移交
RUP将软件开发过程划分为4个阶段：初始阶段、细化阶段、构建阶段和移交阶段。每个阶段都包括多个迭代循环，在每个迭代中，都要完成一定的工作、得出一定的成果，同时进行评审和审核，以确保项目进展按计划顺利进行。RUP还提供了许多最佳实践，如用例驱动开发、迭代和增量开发、模型驱动架构等，可帮助开发团队更好地实现需求收集、分析、设计、测试和部署等工作。


31.软件复审

开发阶段——保证可维护
系统分析阶段的复审过程——指出软件的可移植性以及影响维护的系统界面。
系统分析阶段的复审期间——从容易修改，模块化，功能独立出发，评价软件结构和过程。
系统实施的复审——强调编码风格和内部说明文档。

32.依赖关系/组合关系/聚合关系
依赖关系：
若类 A 仅在其方法 Method1 中定义并使用了类 B 的一个对象，类 A 其他部分的代码都不涉及类 B，那么类 A 与类 B 的关系是依赖关系。因为类 A 只在其中的一个方法中使用到了类 B，而且没有持有或者继承类 B，所以这种关系可以称为依赖关系。
```java
public class Adder {
    public int add(int a, int b) {
        return Math.addExact(a, b);
    }
}
```
聚合关系
假设我们要设计一个学校管理系统，其中有一个班级（Class）类和一个学生（Student）类，一个班级中包含多个学生，同时一个学生也只能归属于一个班级。那么 Class 类可能被设计为包含一个 Student 类型的数组属性，代码如下：
```java
public class Class {
    private Student[] students;

    public Class(Student[] students) {
        this.students = students;
    }

    public Student[] getStudents() {
        return students;
    }
}
```

组合关系
假设我们要设计一个图书馆系统，其中有一个 Book 类和一个 Library 类。该系统需要保证只有当还完所有借书记录之后，才能将一本书从库存中移除。因此，一个 Library 实例可能会持有多个 Book 类的实例，并且当这个 Library 实例被销毁时，其所有的 Book 实例也应该随之被销毁。代码如下：

```java
public class Library {
    private List<Book> books;

    public Library(List<Book> books) {
        this.books = books;
    }

    // 其他方法省略...

    @Override
    protected void finalize() throws Throwable {
        for (Book book : books) {
            book.finalize();
        }
        super.finalize();
    }
}

public class Book {
    // 其他属性、方法等省略...

    @Override
    protected void finalize() {
        System.out.println("Book instance is going to be destroyed.");
    }
}

```

33.1NF/2NF/3NF/BCNF
1NF：第一范式，保证每个属性具有原子性，也就是确保每个属性不能再分成更小的部分。如果出现复合属性，则需要将其拆分成独立的属性。同时，每个属性的值都是单一的，不能包含多个值。

2NF：第二范式，要求实体的非主属性必须完全依赖于主键。也就是说，任何一个非主属性不能依赖于主键的一部分，而应该依赖于整个主键。

3NF：第三范式，要求在2NF基础上，除了主键之外的其他属性之间不能存在传递依赖关系。也就是说，如果 A → B，B → C，那么就要把 B 从表中剥离出来，形成两张表。

BCNF：巴斯-科德范式，是指消除所有属性对于候选键的部分和传递函数依赖关系。通俗的解释是，表中的每个属性都依赖于整个候选键，而不是依赖于候选键的一部分。




34.自然连接

自然连接（Natural Join）是一种基于两张或多张表之间相同列名的连接方式，它会将这些相同列名的列作为连接条件进行匹配，并返回所有满足条件的行。

自然连接不需要指定连接条件，因为它会自动根据列名相同的列进行连接。例如，假设有两张表A和B，它们都包含一个叫做“id”的列，那么使用自然连接对这两张表进行连接操作时，会自动将A表中的"id"列与B表中的"id"列进行匹配，返回所有匹配成功的记录。

自然连接的语法格式如下：
```
SELECT *
FROM table1
NATURAL JOIN table2;
```

35.强连通的有向图
一个强连通的有向图中，每个顶点都能到达所有其他顶点，也就是说，对于每一对顶点 (i,j)，都存在从顶点 i 到顶点 j 的路径以及一条从顶点 j 到顶点 i 的路径。因此，如果每个顶点只有出度而没有入度，或者每个顶点只有入度而没有出度，那么该有向图的边数最小，即 E=V-1。反之，当每个顶点既有出度也有入度时，该有向图的边数可以大于 2V。

36.AOV/AOE
AOV网以顶点表示活动，前驱活动优于后继活动完成。AOV网（Activity On Vertex NetWork）用顶点表示活动，边表示活动（顶点）发生的先后关系。**拓扑排序**
AOE网以边表示活动，通常用来估算工程的完成时间。

```go
    result := []int{}
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        // 加入结果集
        result = append(result, node)
        // 不断的从终端节点出发判断能不能达到某个顶点
        for _, v := range reverseGraph[node] {
            inDegrees[v]--
            // 将入度为0的节点入队
            if inDegrees[v] == 0 {
                queue = append(queue, v)
            }
        }
    }
```
37.栈模拟队列

要用两个栈来模拟队列，可以分别定义一个输入栈和一个输出栈。在入队操作时，将元素放入输入栈中；在出队操作时，首先检查输出栈是否为空，如果不为空，则直接从输出栈中弹出一个元素；如果输出栈为空，则将输入栈中的所有元素依次弹出并压入输出栈中，再从输出栈中弹出一个元素。这样就能保证队列的先进先出特性、

38.完全二叉树
直观地来讲，完全二叉树可以看作是将二叉树的节点按照从上到下、从左到右的顺序排列后得到的结果。其中，除了最后一层之外，其他所有层都填满了节点，最后一层的节点都靠左排列。

39.XML
XML文件的第一行必须是声明该文件是XML文件,以及它所使用的XML规范版本。在文件的前面不能够有其他元素或者注释。所有的XML文档必须由一个根元素。xML文档中第一个元素就是根元素。所有XML文档必须包含一个单独的标记来定义，所有其他元素都必须成对地在根元素中嵌套。XML文档有且只能有一个根元素，所有的元素都可以有子元素，子元素必须正确地嵌套在父元素中，在XML中规定，所有标识必须成对出现，有一个开始标识，就必须有一个结束标识，否则将被视为错误。

40.CISC/RISC

CISC代表复杂指令集计算机，RISC代表精简指令集计算机。

CISC处理器拥有大量的复杂指令，能够在一条指令中执行多个低级操作。这使得CISC处理器能够用更少的指令执行复杂操作，但同时也使得硬件设计更加复杂。

相比之下，RISC处理器只有较小的、更简单的指令集合，每条指令只执行一个操作。这意味着执行复杂操作需要更多的指令，但硬件设计更为简单，处理器可以更快地执行指令。

这两种体系结构都有各自的优缺点，选择哪种取决于项目的具体需求。CISC处理器通常用于需要快速执行复杂指令的应用程序，而RISC处理器通常用于需要快速执行简单指令或者对功耗有要求的应用程序。RISC采用硬布线控制逻辑结构。

```
对比：
CISC  RISC
可变指令长度  固定指令长度
多周期执行 单周期执行

```

41.浮点数
浮点数的一般表示形式为N = 2E × F，其中 E 为阶码，F 为尾数。业标准 IEEE754 浮点数格式中阶码采用移码、尾数采用原码表示。规格化表示要求将尾数的绝对值限定在区间`[0.5, 1)`

为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高位数必须是一个有效值，即1/2≤/F1<1，在尾数用补码表示时，
规格化浮点数应满足尾数最高数位与符号位不同，即当1/2≤F
＜1时，应有0.1xX…x形式；当-1≤M<1/2时，应有1.0xX.…x形式。
需要注意的是，当M=1/2时，对于原码来说是规格化数，而对于补码来说不是规格化数。
两个浮点数进行相加运算时，首先需要对阶（使它们的阶码一致），然后再进行尾数的相加处理。

42.海明码是一种可以纠正一位差错的编码。它是利用信息位为k位，增加r位元余位，构成一个n=k+r位的码字，然后用个个监督关系式产生的r个校正因子来区分无错和在码字中的n个不同位置的一位错。海明码是利用**奇偶性来检错和纠错**的校验方法。海明码的构成方法是：在数据位之间插入k个校验位，通过扩大码距来实现检错和纠错。

43.CRC
循环冗余校验码(CRC码，CRC=Cyclic Redundancy Check)：是数据通信领域中最常用的一种差错校验码，其特征是信息字段和校验字段的长度可以任意选定。
生成CRC码的基本原理：
```
信息位： 1100 1010 101 生成多项式：X^4+ X^3+X+1,
1100 1010 101+5个0 = 1100 1010 101 00000
X^4+ X^3+X+1=11011
1100 1010 101 00000与 11011异或运算
11001 010 101 00000
11011
   10 010 
   11 011
    1 001 1
    1 101 1
      100 00
      110 11
       10 111 
       11 011
        1 100 0
        1 101 1
            1 1000
            1 1011
            0 0011

```

44.Cache
主要由两部分组成:
- 控制部分和Cache存储部分。
- Cache存储部分用来存放主存的部分拷贝(备份)。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中；若不在则没有命中。命中时直接对Cache存储器寻址。未命中时，若是读取操作，则从主存中读取数据，并按照确定的替换原则把该数据写入Cache存储器中；若是写入操作，则将数据写入主存即可。

45.CA
数字证书是由权威机构—CA证书授权(Certificate Authority)中心发行的，能提供在lnternet上进行身份验证的一种杈威性电子文档，人们可以在互联网交往中用它来证明自己的身份和识别对方的身份。数宇证书采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己设定一把特定的仅为本人所有的私有密钥(私钥)，用它进行解密和签名；同时设定一把公共密钥(公钥)并由本人公开，为一组用户所共享，用于加密和验证签名。当发送一份保密文件时，**发送方使用接收方的公钥对数据加密**，而接收方则使用自己的私钥解密，这样信息就可以安全无误地到达目的地了。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。公开密钥技术解決了密钥发布的管理问题，用户可以公开其公开密钥，而保留其私有密钥。

46.位图/矢量图
矢量图形是用一系列**计算机指令**来描述和记录一幅图的内容，即通过指令描述构成一幅图的所有直线、曲线、圆、圆弧、矩形等图元的位置、堆数和形状，也可以用更为复杂的形式表示图形图像，在处理图形图像时根据图元对应的数学表达式进行编辑和处理。在屏幕上显示一幅图形图像时，首先要解释这些指令，然后将描述图形图像的指令转化成屏幕上显示的形状和颜色。编辑矢量图的软件通称称为绘图软件，如适于绘制机械图、电路图的Auto CAD软件等。这种软件可以产生和操作矢量图的各个成分，并对矢量图形进行移动、缩放、叠加、旋转和扭曲等变化。编辑图像时将指令转变成屏幕上所显示的形状和颜色，显示时也往往能看到绘图的过程。由于所有的矢量图形部分都可以用数学的方法加以描述，从而使得计算机可以对其进行任意放大、缩小、旋转、变形、扭曲、移动和叠加等变换，而不会破坏图像的画面，但是，用矢量图形格式表示复杂图像（如人物、风景照片），并且要求很高时，将需要花费大量的时间进行变换、着色和处理光照效果等。因此，矢量图形主要用于标识线框型的图画、工程制图和美术字等。
位图图像是指用**像素点来描述的图**，图像一般是用摄像机或扫描仪等输入设备捕捉实际场景画面，离散化为空间、亮度、颜色（交度）的序列值，即把一幅彩色图或灰度图分为许许多多的像素（点），每个像素用若干二进制位来指定该像素的颜色、亮度和属性。为因图像在计算机内存中由一组二进制位组成，这些位定义图像中每个像素点的颜色和亮度，图像适合于 表现比较细腻，层次较多，色彩较丰富，包含大量细节的图像，并可直接、快速地在屏幕上显示出来，但占用存储空间较大，一般需要进行数据压缩。

47.面向对象分析与设计

OMT (Object Modeling Technique)、Coad-Yourdon Method 和 Booch Method 都是面向对象分析与设计（OOAD）方法。

OMT 是由 James Rumbaugh 等人提出的一种面向对象分析和设计方法，主要提供了对象建模、动态建模和功能建模等方面的技术。OMT 的核心概念包括类、对象、继承、聚合、关联、操作、消息等。常用的建模符号包括类图、对象图、状态图、活动图等。

Coad-Yourdon Method 最初是由 Coad 和 Yourdon 提出的结构化分析与设计方法改进而来。它在传统的结构化分析和设计方法的基础上，引入了面向对象的概念和技术，具有良好的可视化效果和易学习的特点。
Coad-Yourdon 方法主要包括三个阶段：领域建模、系统建模和对象建模。其中，领域建模定义了系统所涉及的领域和相关概念；系统建模定义了系统的结构和功能；对象建模则定义了系统中的对象、类和关系。

Booch Method 是 Grady Booch 提出的一种面向对象软件开发方法，提供了用于对象建模、动态建模和物理建模等方面的技术。
Booch Method 强调了面向对象分析、设计和实现中的可重用性和模块化，并提供了符号和图形语言来描述对象、类、继承、多态性、消息等，同时也提供了用于系统实现和测试的指南和工具

48.中间代码

“中间代码”是一种简单且含义明确的记号系统，与具体的机器无关，可以有若千种形式。可以将**不同的高级程序语言翻译或同一种中问代码**，由于与具体机器无关，使用中问代码有利于进行与机器无关的优化处理，以及提高编译程序的**可移植性**

49.软件设计原则
模块大小适中。减少调用，**多扇入**。少扇出。**单出口**。

50.面向对象技术

面向对象**分析**阶段：认定对象，组织对象，对象问的相互作用，基于对象的操作。
面向对象**设计**阶段：识别类及对象、定义属性、定义服务、识别关系、识别包。
面向对象程序设计：程序设计范型、选择一种OOPL。
面向对象测试：算法层、类层、模板层、系统层。

51.面向对象设计

接口分离原则：使用多个专门的接口要比使用单一的总接口要好。

开放-封闭原则：对扩展开放，对修改关闭。

共同封闭原则：包中的所有类对于同一性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包里的所有类产生影响，而对于其他的包不造成任何影响。

共同重用原则：一个包里的所有类应该是共同重用的。如果重用了包里的一个类，那么就要重用包中的所有类。

52.归并排序
```go
package main

import "fmt"

func mergeSort(arr []int) []int {
    if len(arr) < 2 {
        return arr
    }
    mid := len(arr) / 2
    return merge(mergeSort(arr[:mid]), mergeSort(arr[mid:]))
}

func merge(left, right []int) []int {
    size, i, j := len(left)+len(right), 0, 0
    slice := make([]int, size, size)
    for k := 0; k < size; k++ {
        if i > len(left)-1 && j <= len(right)-1 {
            slice[k] = right[j]
            j++
        } else if j > len(right)-1 && i <= len(left)-1 {
            slice[k] = left[i]
            i++
        } else if left[i] < right[j] {
            slice[k] = left[i]
            i++
        } else {
            slice[k] = right[j]
            j++
        }
    }
    return slice
}

func main() {
    arr := []int{9, 4, 5, 6, 10, 3, 8, 2, 7, 1}
    fmt.Println("Unsorted array:", arr)
    fmt.Println("Sorted array:  ", mergeSort(arr))
}
```
归并排序最好：NlogN
归并排序最坏：NlogN

53.Huffman 编码
基本思想：使用更短的二进制码来代表出现频率较高的字符，而使用更长的二进制码来代表出现频率较低的字符。

统计出每个字符在文本中出现的频率，并根据频率构建最小堆（即次数最少的元素在前面）。

54.ARP协议/RARP

ARP，即地址解析协议（Address Resolution Protocol），是一种用于将网络层地址（如 IP 地址）解析为链路层地址（如 MAC 地址）的协议。

在一个 IP 网络中，当主机 A 的网络层需要发送数据到另一个主机 B 时，它需要知道目标主机 B 的 MAC 地址以便构建出帧来正确地把数据包发往目标。由于 ARP 协议可以查询目标主机的 MAC 地址，所以在发送数据前通常会先向局域网内广播一个 ARP 请求，该请求同时包含源主机的 IP 和 MAC 地址以及目标主机的 IP 地址。其他主机收到该请求后会检查自己的 IP 地址是否与请求中的目标地址匹配，如果匹配则会返回自己的 MAC 地址给请求方；否则就忽略该请求。

当请求方接收到 ARP 响应时，它将把返回的 MAC 地址缓存起来，以后再向该目标主机发送数据时就可以直接使用该 MAC 地址，无需再进行 ARP 查询。缓存的 ARP 条目有一个存活时间，过期后需要重新查询。

RARP 协议则是将一个 MAC 地址解析为相应的 IP 地址。在某些局域网环境下，由于没有 DHCP 服务器或者其他原因，某些主机可能无法获得自己的 IP 地址。这时候，RARP 就可以帮助它们了。主机会广播一个 RARP 请求消息，请求其它主机帮助它获取自己的 IP 地址。收到请求的主机会根据 MAC 地址查找相应的 IP 地址，并将其返回给请求主机。

55.路由协议

> 是指在计算机网络中，用于维护路由表和决策数据包传输路径的一组规则与协议。
> 静态路由协议：由网络管理员手动配置路由器上的路由表，适用于小型网络或者稳定的网络环境，因为对网络拓扑结构的变化会造成管理上的困难。
> RIP（Routing Information Protocol）：是一种基于距离向量的路由协议。RIP 协议通过交换整个路由表或部分路由表来实现路由信息的传播，同时每隔一段时间会向邻居发送路由通告，并请求邻居发送其相邻路由表，最后选取最优路径作为路由信息。
> BGP（Border Gateway Protocol）：是一种路由协议，主要运用在互联网中的边缘路由器之间，用来交换路由信息，以便于实现路由的选择和控制。BGP 采用了基于路径、自治系统号等多种因素的决策过程，是一种高级的路由协议。
> OSPF（Open Shortest Path First）：是一种链路状态路由协议。OSPF 通过不断地广播链路状态信息来更新本地的链路状态数据库，使用 Dijkstra 算法计算得出全网中各节点之间的最短路径，并维护路由表。

工作原理：

路由协议通过在路由器之间共享路由信息来支持可路由协议，路由信息在相邻路由器之间传递，路由协议创建了路由表，描述了网络的拓扑结构。

56.对称加密/非对称加密

非对称加密：RSA/ECC/DSA
对称加密：DES 3DES AES

消息摘要算法：SHA/MD5

57.SQL注入

把SQL语句加入，获取到数据库的访问权限。

58.四层网络模型

链路层：PP2P链路层，为链路加密
网络层：IPSec工作在网络层，为数据报文加密
传输层：Https SSL为传输层以上的数据加密
应用层：TLS为两个通信应用程序之间提供保密性和数据完整性

59.软件详细设计阶段

每个模块进行详细的算法分析，代码设计，输入，输出设计，用户界面设计。

60.软件的概要设计阶段
软件体系结构设计，系统划分模块，确定每个模块的功能，确定每个模块的调用关系，确定模块间的接口。模块间传递的信息。

61.软件可靠性/可维护性/可用性


MTBF：Mean Time Between Failure,平均失效间隔

```text
假设您有一台运行 24 小时的印刷机。在那段时间里，它失败了两次，每次都需要一个小时才能恢复运行。 

因此，它总共运行了 22 小时（24 小时减去维修所需的两个小时）。二十二除以二，失败的总数等于 11

```

MTTF：Mean Time To Failure，平均无失效时间

```text
我们可能有四个烧坏的灯泡，它们分别运行了 20、22、26 和 18 小时。我们将这些数字相加得到 86。 

当我们将其除以灯泡数量（即四个）时，我们得到 MTTF 为 21.5 小时。 
```

> MTTF是用来衡量“不可修复”的元器件（系统、资产等都可以）的“寿命”（可靠性），统计方法就是收集大量的元器件的寿命然后取平均值。MTTF不是MTBF的一部分，两者的应用场景是不同的

> 不可修复故障”的元器件，可靠性衡量指标就是MTTF
> 对于“可修复故障”，衡量可靠性指标就是MTBF

MTTR：Mean Time To Repair,平均恢复时间
软件可靠性

```
MTTF/(MTTF+1)

```
可维护性
```
MTTR/(MTTR+1)
```
可用性
```
MTBF/(1+MTBF)
```



63.维护类型

改正性维护：修复错误。
适应性维护：因为外部环境的改变，修改软件
完善性维护：新的功能，新的要求。
预防性维护：预先修改，满足未来。



64.面向对象分析
识别对象-组织对象-描述对象间的关系-确定对象的操作-定义对象的内部信息。


65.稀疏矩阵的十字链表压缩

在节点中除了存储元素值外，还会存储该元素在行列方向上的前驱节点和后继节点。具体来说，每个节点包含以下字段：
```
row：该元素所在的行号。
col：该元素所在的列号。
value：该元素的值。
down：下一个在该元素同一列的节点。
right：下一个在该元素同一行的节点。
rhead：该元素所在行的头节点。
chead：该元素所在列的头节点。
```

66.稀疏矩阵的三元顺序表压缩

稀疏矩阵的三元组表是一种常用的压缩存储方式，可以用于节省稀疏矩阵所需的存储空间。它将矩阵中非零元素的行列坐标和数值存储在一个三元组中，通常采用如下格式表示：

```
(i, j, v)
```

67.排序算法

```go
func InsertSort(arr []int){
    for i:=1;i<len(arr);i++{
        // 找到大于的数字，那么前面的位置就是该数字
        for j:=i-1;i<i;j++{
            if arr[j]>arr[j]{
                arr[j-1],arr[i] = arr[i],arr[j-1]
            }
        }
    }
}

```

```go
func BubbleSort(arr []int){
    for i:=0;i<len(arr)-1;i++{
        // 找到大于的数字，那么前面的位置就是该数字
        for j:=1;j<=len(arr)-1-i;j++{
            if arr[j]<arr[j-1]{
                arr[j-1],arr[i] = arr[i],arr[j-1]
            }
        }
    }
}

```

```go
func SelectSort(arr []int){
    for i:=0;i<len(arr)-1;i++{
        minIndex:=i
        // 找到大于的数字，那么前面的位置就是该数字
        for j:=i+1;j<len(arr);j++{
            if arr[j]<arr[minIndex]{
                minIndex = j
            }
        }
        arr[i] ,arr[minIndex]= arr[minIndex],arr[i]
    }
}

// 堆排序
func heapSort(arr []int) {
    n := len(arr)

    // 构建大根堆
    for i := n/2 - 1; i >= 0; i-- {
        adjustHeap(arr, i, n)
    }

    // 取出堆顶元素，与末尾元素交换位置
    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        adjustHeap(arr, 0, i)
    }
}

// 调整大根堆
func adjustHeap(arr []int, start, end int) {
    temp := arr[start]
    for k := start*2 + 1; k < end; k = k*2 + 1 {
        if k+1 < end && arr[k+1] > arr[k] {
            k++
        }
        if arr[k] > temp {
            arr[start] = arr[k]
            start = k
        } else {
            break
        }
    }
    arr[start] = temp
}

// 快速排序
func quickSort(arr []int, left, right int) {
    if left < right {
        pivotIndex := partition(arr, left, right)
        quickSort(arr, left, pivotIndex-1)
        quickSort(arr, pivotIndex+1, right)
    }
}

// 分区操作
func partition(arr []int, left, right int) int {
    pivot := arr[left]
    for left < right {
        for left < right && arr[right] >= pivot {
            right--
        }
        arr[left] = arr[right]
        for left < right && arr[left] <= pivot {
            left++
        }
        arr[right] = arr[left]
    }
    arr[left] = pivot
    return left
}

// 归并排序
func mergeSort(arr []int) []int {
    length := len(arr)
    if length <= 1 {
        return arr
    }

    mid := length / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])

    return merge(left, right)
}

// 合并两个有序数组
func merge(left []int, right []int) []int {
    result := make([]int, 0)

    for len(left) > 0 && len(right) > 0 {
        if left[0] < right[0] {
            result = append(result, left[0])
            left = left[1:]
        } else {
            result = append(result, right[0])
            right = right[1:]
        }
    }

    result = append(result, left...)
    result = append(result, right...)

    return result
}

```


77.FTP SFTP TFTP ICMP 

FTP：文件传输协议（File Transfer Protocol），它是为在网络上进行文件传输而开发的一种标准协议。
SFTP：安全文件传输协议（Secure File Transfer Protocol），是基于SSH协议之上的一种加密传输文件的协议。SFTP是一种与FTP不同的完全独立的协议。
TFTP：简单文件传输协议（Trivial File Transfer Protocol），TFTP是一个小巧、简单易用的文件传输协议，主要用于无需认证和登录的场景，如在内网中分发软件镜像。
ICMP：Internet控制消息协议（Internet Control Message Protocol），是TCP/IP协议族的一个子协议，它用于在IP网络上发送控制信息。ICMP通常用于网络设备间交换状态信息，比如路由器、交换机等设备所发生的故障以及转发表更改等情况。

78.四层网络模型各层的协议

应用层：HTTP、FTP、SMTP、DNS

HTTP（HyperText Transfer Protocol）：万维网上块数据的传输协议，用于浏览器与Web服务器之间的通信。
FTP（File Transfer Protocol）：用于在网络上进行文件传输的协议。
SMTP（Simple Mail Transfer Protocol）：用于电子邮件的发送和接收协议。
DNS（Domain Name System）：将域名转换为 IP 地址的系统。

传输层：TCP、UDP
TCP（Transmission Control Protocol）：提供端到端的可靠数据传输服务和协议，包括流量控制和错误纠正等机制。
UDP（User Datagram Protocol）：简单的无连接的传输协议，不保证可靠性，但具有较低的延迟和更好地支持广播和多播。

网络层：IP、ICMP、ARP：
IP（Internet Protocol）：负责实现数据包的传输和路由选择。
ICMP（Internet Control Message Protocol）：用于在网络中传递控制消息，例如ping命令使用的“回显请求”和“回显应答”就是基于ICMP的。

ARP（Address Resolution Protocol）：将IP地址转换成MAC地址的协议。
数据链路层：Ethernet、PPP
Ethernet（以太网）：最常见的有线局域网络传输协议。
PPP（Point-to-Point Protocol）：用于在两个计算机之间进行点对点的数据通信。


79.DDOS
DDoS攻击（Distributed Denial-of-Service Attacks）是指攻击者通过利用网络上的大量计算机或网络设备，向目标服务器或网络资源发起大量伪造的请求，以使得正常用户无法访问服务器或网络资源。攻击者会使用包括僵尸网络、木马程序等手段将自己控制的设备进行扫描、感染，并发起DDoS攻击。这种攻击方式具有流量大、占用带宽多、难以防御等特点，严重影响了网站的可用性和稳定性。

80.ACL/SNAT

ACL是Access Control List（访问控制列表）的缩写，它是一种用于网络安全的技术手段。通过在设备上设置ACL规则，可以限制网络数据包在网络中的流动，防止恶意攻击、保障网络安全等。

而SNAT是Source Network Address Translation（源网络地址转换）的缩写，是一种网络地址转换技术。在一个网络中，当**多个主机需要共享同一个公网IP地址时，就需要使用SNAT技术。**


81.动态绑定和静态绑定

动态绑定和静态绑定是面向对象编程中的两个重要概念，它们描述的是代码执行时方法调用的解析过程。

静态绑定（Static Binding）也称为早期绑定，指在程序编译期间就确定了调用哪个方法。例如，如果一个父类有一个名为foo()的方法，它会被子类继承，但是如果在子类中重写了这个方法并且通过父类型引用调用该方法，则会调用从父类继承的原始实现。这是因为编译器在编译时已经将调用绑定到了父类上，因此无论运行时该引用引用的是父类还是子类，都只会调用父类的foo()方法。

相反，动态绑定（Dynamic Binding）也称为晚期绑定，是在程序运行时根据实际类型来确定调用哪个方法。当使用一个子类对象调用其父类的方法时，该方法的调用将在运行时解析为该子类的方法。这是因为编译器无法提前确定该引用的真实类型，因此必须等到运行时才能确定。

82.SMTP/POP3/IMAP
SMTP:邮件传送协议
POP3：邮件收取协议
IMAP：交互邮件访问协议

83.移码

不管是正数的补码还是负数的补码，符号位取反就可以。

0 000 0000  反码：0 000 0000 补码：0 000 0000 移码：1 000 0000
1 000 0000  反码：1 111 1111 补码：0 000 0000 移码：1 000 0000

如果产生了进位，那么符号位可能改变
比如-0 的反码：1 111 1111 补码：0 000 0000 移码： 1 000 0000


奇偶校验 (Parity Codes)是一种简单有效的校验方法。这种方法通过在编码中增加一位 校 验 位 来 使 编 码 中 1 的 个 数 为 奇 数 (奇 校 验 ) 或 者 为 偶 数 (偶 校 验 ) ， 从 而 使 码 距 变 为 2 。 对
于奇校验，它可以检测代码中奇数位出错的编码， 但不能发现偶数位出错的况



84.直接映射

Cache 被分成了N行，主存被分成M个区 ，每个区是N行。

那么主存地址格式：

```
区号 + 块号 + 块内地址字号
       M       N
```
有一处理机，主存容量1MB，字长1B，块大小16B；Cache容量4KB，若cache采用直接映射，请给出2个不同标记的内存地址，它们映射到同一个cache行。

```
区号：1MB/4KB=2^8
块号：4KB/16B=2^8
块内地址字号：16B/1B=2^4
```

```
人话翻译版：
主存储的大小是多少个Cache?：1MB/4KB=2^8
Cache的大小是多少个块?：4KB/16B=2^8
块大小是多少个字节？：16B/1B=2^4
```
块号相同的块无法同时调入Cache

85.全相联映射

若数据在主存和Cache之间按块传送单位为512字节。Cache大小为8KB，主存容量为1MB ,求其主存的地址格式。

```
主存的大小是多少个块？1MB/512B=1MB/（0.5KB）=1024KB*2=2的11次方
块大小是多少个字节？521B=2的9次方
```
主存调入不受限制，无法从主存块号直接获取Cache块号
86.组相联映射

某计算机按字节寻址，主存有2K个块，每块32个字节。 Cache由64个块组成，每组8块（8路组相联）。请表示主存地址格式。给内存地址为A21FH和C028H两个地址对应的标记、组号和字号。

```
主存的大小是多少个组？2KB/8=2的8次方
Cache的大小是多少个组？64/8=2的3次方
块是多少个字节：2的5次方
8 3 5
```
主存任何区的0组只能存到Cache 的0组

87.数字签名和数字加密的区别

数字签名：接收方用发送方的公钥解密码，发送方用自己的私钥加密。采用了非对称加密。

数字加密：接收方用自己的私钥解密，发送方用接收方的公钥加密。非对称加密+对称加密。


88.KMP算法

串的第一位和第二位字符对应的next值分别为固定值0、1

串的其他位对应的next值为该字符之前的字符串的公共最长匹配前缀和后缀的长度加1

89.最小生成树
Kruskal：
找到连接所有顶点且边的总权值的最小子图。

```go
type Edge struct{
    from int
    to int
    weight int
}

func kruskal (n int,edges []Edge) []Edge{
    //边要按照从小到大排序
    sort.Slice(edges ,func (i int,j int)bool{
        return edges[i].weight < edges[j].weight
    })
    // 初始化并集
    // unionSet[son] = father
    unionSet:= make(map [int]int,n)
    for i:=0;i<n;i++{
        unionSet[i] = i
    }
    var res []Edge
    for _,e:= range edges{
        // 查两个点的父节点是否相同
        fromFather:=find(unionSet,e.from)
        toFather := find(unionSet,e.to)
        if fromFather!= toFather{
            res= append(res,e)
            // 两个联通块合并为一个
            unionSet[e.from]=e.to
        }
    }
    return res
}

func find(unionSet map[int]int, x int)int{
    son:=x
    for  son!=unionSet[son] {
         son=  unionSet[son]
    }
}
```

90.AOV网

顶点：活动。
有向边：活动间的优先关系

AOE：顶点表示事件，顶点所表示的事件实际上就是某些活动已经完成
有向边：表示活动。顶点所表示的 事件是指该顶点所有进入边所表示的活动均己完成、从它出发的边所表示的活动均可以开始的一种事件。

A O E 网 中 至 少 有 一个 入度为0 的开始顶点，称为源点。另外，应有 一个出度为0 的结束顶点，称为汇点。AOE 网中 不应存在有向回路，否则整个工程无法完成。与AOV网不同，AOE 网所关心的问题如下。 (1 ) 完 成 该 工程 至 少 需 要 多 少 时 间 ?
(2 ) 哪 些 活 动 是 影 响 整 个 工 程 进 度 的 关 键 ?
由于AOE 网中的某些活动能够并行地进行，因此完成整个工程所需的时间是从开始顶点 到结束顶点的最长路径的长度 。这里的路径长度是指该路径上的权值之和。


91.顺序查找/折半查找/分块查找

顺序查找的平均长度为：（n+1）/2
折半查找的平均长度为：（n+1）/n * log2(n+1)-1 在n的值比较大的时候大概为：log2(n+1)-1
分块查找的平均查找长度为：L0+Lw是索引查找和块内查找之和。

92.B树

B树是一种自平衡的树形数据结构，主要用于在磁盘上存储和检索大量数据。它在数据库和文件系统等领域得到了广泛应用。B树的关键特点是每个节点可以有多个子节点，这有助于提高磁盘上的存储和检索效率。
以下是B树的一些主要特性：
节点的子节点数量：B树的每个节点可以有多个子节点，通常用阶数（order）表示。一个m阶的B树，每个节点最多有m个子节点。
平衡性：B树的所有叶子节点都在同一层，这保证了查找、插入和删除操作的时间复杂度为O(log n)，其中n是节点数量。
节点关键字数量：每个非根节点至少有ceil(m/2) - 1个关键字，至多有m - 1个关键字。根节点至少有一个关键字，除非它是一棵空树。
关键字排序：节点中的关键字按照升序排列。对于每个节点，其子节点的关键字都在父节点的关键字范围内。
B树的主要操作包括查找、插入和删除。由于B树的自平衡特性，这些操作的时间复杂度都是O(log n)

节点结构：
```go
type Node struct {
    keys     []int
    children []*Node
    isLeaf   bool
}
```
B树结构：
```go
type Node struct {
    keys     []int
    children []*Node
    isLeaf   bool
}
```

```go

func (b *BTree) Search(key int) *Node {
	return b.search(b.root, key)
}

func (b *BTree) search(node *Node, key int) *Node {
	if node == nil {
		return nil
	}

	i := 0
	for i < len(node.keys) && key > node.keys[i] {
		i++
	}

	if i < len(node.keys) && key == node.keys[i] {
		return node
	}

	if node.isLeaf {
		return nil
	}

	return b.search(node.children[i], key)
}

```
插入
```go
func (b *BTree) Insert(key int) {
	root := b.root
	if len(root.keys) == 2*b.t-1 {
		newRoot := &Node{isLeaf: false}
		b.root = newRoot
		newRoot.children = append(newRoot.children, root)
		b.splitChild(newRoot, 0)
		b.insertNonFull(newRoot, key)
	} else {
		b.insertNonFull(root, key)
	}
}

func (b *BTree) splitChild(parent *Node, index int) {
	node := parent.children[index]
	newNode := &Node{isLeaf: node.isLeaf}

	mid := b.t - 1
	newNode.keys = append(newNode.keys, node.keys[mid+1:]...)
	node.keys = node.keys[:mid]

	if !node.isLeaf {
		newNode.children = append(newNode.children, node.children[mid+1:]...)
		node.children = node.children[:mid+1]
	}

	parent.keys = append(parent.keys[:index], append([]int{node.keys[mid]}, parent.keys[index:]...)...)
	parent.children = append(parent.children[:index+1], append([]*Node{newNode}, parent.children[index+1:]...)...)
}

func (b *BTree) insertNonFull(node *Node, key int) {
	i := len(node.keys) - 1
	if node.isLeaf {
		for i >= 0 && key < node.keys[i] {
			i--
		}
		node.keys = append(node.keys[:i+1], append([]int{key}, node.keys[i+1:]...)...)
	} else {
		for i >= 0 && key < node.keys[i] {
			i--
		}
		i++
		if len(node.children[i].keys) == 2*b.t-1 {
			b.splitChild(node, i)
			if key > node.keys[i] {
				i++
			}
		}
		b.insertNonFull(node.children[i], key)
	}
}
```
删除操作涉及较多的边界条件和情况处理，这里仅提供一个简化版的删除操作：
```go
func (b *BTree) Delete(key int) {
	b.delete(b.root, key)
}

func (b *BTree) delete(node *Node, key int) {
	// 简化版删除操作，仅适用于节点关键字数量大于t-1的情况
	i := 0
	for i < len(node.keys) && key > node.keys[i] {
		i++
	}

	if i < len(node.keys) && key == node.keys[i] {
		if node.isLeaf {
			node.keys = append(node.keys[:i], node.keys[i+1:]...)
		} else {
			// 更复杂的情况需要处理子节点关键字数量的调整
		}
	} else {
		if !node.isLeaf {
			b.delete(node.children[i], key)
		}
	}
}
//这个实现仅涵盖了B树的基本操作，实际应用中可能需要处理更多的边界条件和优化。在实现过程中，我们需要关注代码的可读性、可维护性和性能。同时，不断学习和实践有助于我们更好地理解B树的原理和应用。
```
93.直接插入排序/冒泡排序/简单选择排序

直接插入排序:
```
总比较次数：n(n-1)/2
总移动次数：(n+3)(n-1)/2
时间复杂度为O(n的二次方)
空间复杂度为0(1)
```
冒泡排序：
```
总比较次数：n(n-1)/2
总交换次数：n(n-1)/2
时间复杂度为O(n的二次方)
空间复杂度为0(1)
```

简单选择排序：
```
最好情况下，不需要移动元素
总比较次数：n(n-1)/2
总移动次数：3(n-1)/2
时间复杂度为O(n的二次方)
空间复杂度为0(1)
```

快速排序的时间复杂度(好)：O(nlogn)
快速排序的时间复杂度(坏)：O(n的二次方)

希尔排序的时间复杂度：O(n1.3次方)

堆排序的时间复杂度：O(nlogn)


```
直接插入：O(n的二次方) 
简单选择排序：O(n的二次方) 
冒泡排序：O(n的二次方) 
希尔排序：O(n1.3次方)
快速排序：O(nlogn) 空间：O(logn) 
堆排序：O(nlogn)空间：O(1) 
归并排序：O(nlogn) 空间：O(n) 
基数排序：O(d(n+rd))
```

94.外部排序

外部排序就是对大型文件的排序，待排序的记录存放在外存。在排序的过程中，内存只存 储文件的 一部分记录，整个排序过程需要进行多次内外存间的数据交换。
常用的外部排序方法是归并排序， 一般分为两个阶段:在第一阶段，把文件中的记录分段读入内存，利用某种内部排序方法对记录段进行排序并输出到外存的另一个文件中，在新文件中形成许多有序的记录段，称为归并段;在第二阶段，对第一阶段形成的归并段用某种归并方
法进行一趟趟地归并 ， 使文件的有序段逐渐加长 ， 直到将整个 文件归并为一个有序段时为止 。 下面简单介绍常用的 多路平衡归并方法。 平衡归并是指文件经外部排序的第一个阶段后，已经形成 了由若干个初始归并段构成 的 文 件 。 在 这 个 基 础 上， 反 复 将 每 次 确 定 的 石 个 归 并 段 归 并 为 一 个 有 序 段 ， 将 一 个 文 件 上的 记录归并到另一个文件上。重复这个过程， 直到文件中的所有记录都归并为一个有序段。



94.面向对象分析的过程
1-认定対象
2-组织对象
3-对象间的相互作用
4-确定对象的操作
5-定义对象的内部信息

95.面向对象设计的活动
1-识别类及对象
2-定义属性
3-定义服务
4-识别关系
5-识别包

96.面对对象测试
1-算法层
2-类层
3-模版层
4-系统层

97.UML中的四个事物
1-结构事物（类，接口，协作，用例，构件，制品，节点）
2-行为事物（交互，状态机，活动）
3-分组事务（包）
4-注释事务

98.UML的四种关系
1-依赖
2-关联
3-泛化
4-实现


99.活动图
活动图用来：1-对工作流建模。2-对操作建模。
类图用来：1-对系统的语境建模。2-对系统的需求建模。
构件图用来：系统的静态实现建模。
部署图用来：对面向对象系统的物理方面的建模。展现了运行时处理节点以及其中构件的配置。
包图：展现模型本身分解成的组织单元以及其间依赖的关系。

100.创建型设计模式/结构型设计模式/行为型设计模式

创建型设计模式：抽象工厂/单例模式/工厂方法/（生成器模式）建造者模式/原型模式 
- 抽象工厂:提供一个创建一系列相关对象或者依赖对象的接口，而无需制定他们具体的类。
- 原型模式：用原型实例指定创建对象的种类， 并且通过复制这些原型创建新的对象。
- 生成器模式：将一个复杂对象与他的表示分离。
- 工厂方法：定义一个用来创建对象的接口，让子类决定来实例哪一个类
- 单例模式：保证一个类仅仅只有一个实例。

结构型设计模式：

- 适配器：将一个类的接口转化为客户希望的另外一个接口。使得接口不兼容而不能一起工作的类可一起工作。
- 桥接模式：将抽象部分和实现部分分离，使得他们可以独立工作。
- 组合模式：将对象组合成树型结构表示整体-部分的层次结构。
- 装饰器模式：动态的给一个对象添加额外的指责。
- 外观模式：为子系统的一组接口提供一个独立的一致的界面。
- 享元模式：使用共享技术，支持大量细粒度的对象。
- 代理模式：为其他对象提供一种代理以控制堆该对象的访问。

行为型设计模式：

- 责任链：使多个对象都有机会处理请求
- 命令模式：将一个请求封装为对象，从而使得可以用不同的请求对客户进行参数化。
- 解释器模式：给定一个语言，定义他的文法，定义一个解释器，这个解释器用来解释语言中的句子
- 迭代器模式：提供一个方法顺序访问聚合对象的各个元素。
- 中介者模式：用一个中介对象封装一些列对象的交互。使得各个对象之间不需要显示的相互引用。
- 备忘录模式：捕获一个对象的内部状态，在对象之外保存这个状态。
- 观察者模式：定义对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖他的对象被通知并且被自动更新。
- 状态模式：允许一个对象在其内部状态改变的时候改变他的行为。
- 策略模式：定义一系列的算法，把他们一个个的封装起来，使得他们可以相互替换。
- 模版方法：定义操作的算法骨架，将一些步骤延迟到子类，不改变算法的结构下即可重定义该算算法。
- 访问者模式：表示一下作用于某对象结构中的各种元素的操作，允许在不改变各个元素类的前提的顶一下作用于这些元素的新操作。


100.分治法/动规/贪心/回溯/概率算法

分治法在每层递归上：
> 1-分解。2-求解。3-合并

动规：

> 1-找到最优解。2-递归定义最优解。3-自低向上计算最优解。4-构造最优解。
```go
func dpFunction(nums []int) int {
    n := len(nums)
    // 初始化状态
    dp := make([]int, n)
    dp[0] = nums[0]
    // 状态转移方程
    for i := 1; i < n; i++ {
        dp[i] = max(dp[i-1]+nums[i], nums[i])
    }
    // 返回最终结果
    result := dp[0]
    for i := 1; i < n; i++ {
        if dp[i] > result {
            result = dp[i]
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```
贪心：
> 仅仅根据当前已有的信息作出选择。
```go
type item struct {
    value  int  // 物品的价值
    weight int  // 物品的重量
    ratio  float64  // 物品的价值与重量的比值
}

func knapsack(items []item, capacity int) int {
    sort.Slice(items, func(i, j int) bool {
        return items[i].ratio > items[j].ratio
    })

    totalValue := 0
    for _, item := range items {
        if capacity <= 0 {
            break
        }
        if item.weight <= capacity {
            totalValue += item.value
            capacity -= item.weight
        } else {
            totalValue += int(float64(capacity) * item.ratio)
            capacity = 0
        }
    }

    return totalValue
}
```
回溯：
> 系统的搜索一个问题的所有解或任意解

```go
func backtrack(nums []int, path []int, used []bool, result *[][]int) {
    // 终止条件
    if len(path) == len(nums) {
        temp := make([]int, len(path))
        copy(temp, path)
        *result = append(*result, temp)
        return
    }

    for i := 0; i < len(nums); i++ {
        if used[i] {
            continue
        }
        // 做选择
        path = append(path, nums[i])
        used[i] = true
        // 进入下一层决策树
        backtrack(nums, path, used, result)
        // 撤销选择
        path = path[:len(path)-1]
        used[i] = false
    }
}
```

概率算法：


数值概率算法
```go
import (
    "math"
)

func normalDistribution(x, mean, stdDev float64) float64 {
    return 1.0 / (stdDev * math.Sqrt(2.0*math.Pi)) * math.Exp(-math.Pow(x-mean, 2.0)/(2.0*math.Pow(stdDev, 2.0)))
}
```

>蒙特卡罗算法

```go
import (
    "math/rand"
    "time"
)

func monteCarloSimulation(n int) float64 {
    count := 0
    rand.Seed(time.Now().UnixNano())
    for i := 0; i < n; i++ {
        x := rand.Float64()
        y := rand.Float64()
        if x*x+y*y <= 1.0 {
            count++
        }
    }
    return 4.0 * float64(count) / float64(n)
}

```

> 拉斯维加斯算法:实现了一个二分查找的算法，它的参数是一个有序的整数数组nums和待查找的目标值target。具体来说，我们使用二分查找的方法来在数组中查找目标值，如果找到了目标值，则返回其下标；否则返回-1。

```go
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

```

> 舍伍德算法:通过随机选取一些整数来判断n是否为合数。如果n是合数，则在随机选取的整数中，有很大的概率会选取到n的因子，从而判断出n是合数；否则，如果n是素数，则在随机选取的整数中极少会选取到n的因子，因此可以认为n是素数。
```go
func gcd(a, b int) int {
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    for i := 0; i < 50; i++ {
        a := rand.Intn(n-1) + 1
        if gcd(a, n) != 1        || big.NewInt(int64(a)).Exp(big.NewInt(int64(a)), big.NewInt(int64(n-1)), nil).Int64() != 1 {
            return false
        }
    }
    return true
}
```
101.局域网协议

1-LAN：局域网（Local Area Network，LAN）是指在一个相对较小的地理范围内，如一个建筑物、一个校园或者一个办公室内部，通过一定的通信介质和网络协议，将多台计算机及相关设备互联起来，实现数据和资源共享的计算机网络。

2-以太网：是一种最常见的有线局域网协议，它是IEEE 802.3标准定义的一种协议，采用CSMA/CD（载波监听多路访问/冲突检测）技术，支持多种传输介质和不同的传输速率，从10Mbps到100Gbps不等。

3-令牌环网：是一种基于令牌传递的局域网协议，采用环形拓扑结构，数据经过每个节点时需要获得一个令牌才能继续传输，实现了数据传输的有序性和稳定性。

4-FDDI：是一种基于光纤传输的局域网协议，采用双环结构，支持多种传输介质和不同的传输速率，最高可达100Mbps。

5-无限局域网（CSMA/CA）：无线局域网（Wireless LAN，WLAN）是一种基于无线通信技术的局域网协议，采用CSMA/CA（载波监听多路访问/冲突避免）技术，支持多种无线传输标准，如Wi-Fi、Bluetooth等，可实现无线终端设备的接入和移动性的支持。


102.广域网协议

1-点对点协议PPP:点对点协议（Point-to-Point Protocol，PPP）是一种广泛应用于互联网连接的协议，它建立在串行线路上，用于在两个网络节点之间建立通信连接，支持多种链路层协议和网络层协议。

2-数宇用户线 (XDSL):数字用户线路（x Digital Subscriber Line，xDSL）是一种基于电话线或电缆线的数字传输技术，用于在宽带接入网络中实现用户与网络的连接，常见的xDSL技术包括ADSL、VDSL、HDSL等。

3-数字专线:数字专线是一种点对点的专用电路，用于在远距离的两个网络节点之间建立连接，具有高速传输、低延迟和高可靠性等特点。

4-帧中继:帧中继（Frame Relay）是一种基于帧的广域网协议，用于在广域网中实现不同地理位置的网络节点之间的数据传输，支持多种传输速率和服务质量要求。

5-异步传输模式:异步传输模式（AsynchronousTransfer Mode，ATM）是一种基于分组交换技术的广域网协议，用于在不同地理位置的网络节点之间建立虚拟电路，支持高速传输和多种服务质量要求。

6-X.25:X.25是一种基于分组交换的广域网协议，用于在远距离的网络节点之间建立连接，支持多种传输速率和服务质量要求，常用于远程访问、金融和交通等领域。



103.TCP/IP

1-网络接口层：

2-网络层：ICMP协议（Internet Control Message Protocol）：用于在IP网络中传递控制消息，如错误报告、网络拥塞控制等。常见的ping命令就是基于ICMP协议实现的。ARP协议（Address Resolution Protocol）：用于将IP地址映射到MAC地址，即将网络层的IP地址转换为链路层的MAC地址，以便于数据包的传输。RARP协议（Reverse Address Resolution Protocol）：与ARP相反，用于将MAC地址映射到IP地址，即将链路层的MAC地址转换为网络层的IP地址，以便于主机进行引导和启动操作。ping 工具就是利用ICMP报文进行目标是 否可达测试。

3-传输层：TCP-靠重发保证准确性。

4-应用层：NFS协议（Network File System）：用于UNIX/Linux系统中的文件共享，允许用户在网络上访问远程文件系统。Telnet协议：远程登录协议，允许用户通过网络连接到远端主机，并在远端主机上执行操作。SMTP协议（Simple Mail Transfer Protocol）：用于电子邮件的传输，定义了邮件的格式和传输规则，常用于发送和接收邮件。DNS协议（Domain Name System）：用于将域名解析为IP地址，使用户能够通过域名来访问网络资源。SNMP协议（Simple Network Management Protocol）：用于网络设备的管理和监控，允许管理员通过网络远程管理和监控网络设备。FTP协议（File Transfer Protocol）：用于文件传输，在客户端和服务器之间传输文件，支持文件上传和下载等操作。


104.给定IP地址求子网数（网络数）？主机数？网络地址？广播地址？

1- 求子网掩码
2- 网络数= 2的X次方（X是子网掩码中，借的1的个数）
3- 主机数= 2的Y次方-2（Y是子网掩码中0的个数）
4- 块大小计算 = 256-子网掩码
5- 网络地址 
6- 广播地址

IP地址为202.106.1.0/26 求子网数（网络数）？主机数？网络地址？广播地址？

```text
子网掩码
11111111.11111111.11111111.1100 0000
子网数:
2^2=4
主机数:2^6-2=62
块大小：256-（2^6+2^7）=64
网络地址：202.106.1.0 202.106.1.64  202.106.1.128 202.106.192
广播地址：202.106.1.63 202.106.1.127  202.106.1.191 202.106.255（网络地址主机位取反）
```


105.结构化分析和设计的步骤
1-需求说明
2-结构化分析（得到数据流图，数据字典，加工说明）
3-总体设计。（数据流图中的各个处理转换为模块后模块与模块之间的调用关系）
4-详细设计

106.数据库分析和设计的步骤
1-需求分析
2-概念设计（E-R图）
3-逻辑设计（E-R 图中的实体逐一转换成为一个关系模式）
4-物理设计

107.面向对象分析与设计
1-对系统需求进行建模。（确定参与者，确定需求用例，构造用例模型，记录需求用例描述）
2-定义领域模型（组织对象并记录对象间的概念关系）
3-定义交互，状态和行为。（设计交互图）
4-定义设计类图（设计类图）




