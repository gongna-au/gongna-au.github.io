---
layout: post
title: 软件设计——中级
subtitle:
tags: [软件设计]
comments: true
---

1.立即寻址最快，寄存器寻址次之，直接寻址最慢。
立即寻址将操作数直接嵌入到指令中，因此可以立即访问而不需要额外的内存访问。寄存器寻址涉及将操作数存储在寄存器中，这需要访问寄存器文件，但仍然比直接寻址要快。直接寻址需要额外的内存访问来检索操作数，使其成为三种寻址模式中最慢的一种。

2.PCI总线和SCSI总线
功能不同：PCI是一种系统总线，用于在计算机的各个部件之间传输数据；而SCSI是一种外围设备接口，用于连接和控制存储设备、打印机和其他辅助设备。

PCI总线是并行内总线， SCSI 总线是串行内总线

3.DMA/程序中断

DMA是是指直接内存访问（Direct Memory Access），是一种计算机数据传输技术。它可以在不占用CPU时间的情况下，允许外设（如网卡、声卡、磁盘控制器等）直接访问主存储器中的数据，从而实现高速数据传输。

硬件中断：是指计算机硬件设备向CPU发出的中断信号，例如I/O操作完成、计时器超时等硬件事件。当发生硬件中断时，CPU会停止当前的程序执行，切换到处理该中断的程序，在处理完成后再返回原来的程序。

软件中断：是指通过软件调用专门的中断指令来实现的程序中断。软件中断也被称为“系统调用”，是用户程序获取操作系统功能的主要方式，例如打开文件、读写数据等。

异常：也被称为“陷阱”，是指在程序运行过程中发生了一些不可预知的情况，例如除零错误、访问非法内存地址等。当发生异常时，CPU会停止当前进程的执行，切换到操作系统内核态处理程序来处理异常，处理完成后再返回进程，进程继续执行。

系统调用：是指用户进程运行期间主动进行的一种中断方式，它把控制权交给了操作系统内核。用户进程可以通过系统调用请求操作系统提供服务，例如创建、删除、打开和关闭文件等。

DMA方式可以减轻CPU负担，但是在开始和结束数据传输时，CPU仍然需要进行一定的配置、控制、管理等操作。

DMA方式允许外围设备直接与内存进行数据交换，不需要CPU参与，所以传输速度更快。

4.中断向量提供（ 中断服务程序入口地址）。

5.SRAM

**静态随机存取存储器**，是一种半导体存储器。与**需要定期刷新以保持数据完整性的动态随机存取存储器（DRAM）**不同（使用电容器来存储数据，因此需要定期刷新以避免电容器失去其电荷），它使用锁存电路来存储每个位。 SRAM 比 DRAM 更快、更可靠，但成本更高，存储密度更低。 它通常用于需要快速访问数据的应用程序，例如CPU和微控制器中的**高速缓存存储器**

6.高速缓存存储器（Cache Memory）

是计算机中的一种特殊存储设备，它用于提高计算机处理速度。它通常位于**CPU和RAM**之间，作为CPU读取和写入数据时的一个缓冲区。

7.DRAM

是动态随机存储器（Dynamic Random Access Memory）的缩写。它是一种常用的计算机内存，用来存储正在运行的程序和数据。

8.FLASH

Flash 存储器采用了一种称为闪存的技术，通过在微小的晶体管上存储电荷来表示数字信息。当需要读取存储在 Flash 存储器中的数据时，控制电路将读取的请求发送到存储器芯片，并将数据发送回计算机或其他设备。与 DRAM 不同，Flash 存储器不需要定期刷新，因此可以实现长期数据存储。

由于其快速读取速度和较低的功耗，Flash 存储器已经成为许多电子产品不可或缺的组成部分，如USB闪存驱动器，闪存卡和SSD硬盘驱动器等，这些产品已经替代了早期使用的磁带式和软盘式的存储介质。

9.EEPROM

EEPROM是一种可擦写可编程只读存储器（Electrically Erasable Programmable Read-Only Memory）。它是一种用于存储数据的非易失性存储器，可以在电源关闭时保持存储的数据。EEPROM的特点是可以对其中的数据进行单独的、逐字节的修改，并且这些修改是非破坏性的，也就是说，即使修改了其中的某个字节，其他字节的数据仍然会被保留。EEPROM可以使用电气信号来擦除和编程内部单元，因此不需要物理上移动或更换芯片来实现操作。EEPROM广泛应用于存储小量数据的场景，如记录系统配置信息、校准数据等。由于EEPROM擦写次数有限，所以需要注意合理使用和管理。


10.补码转换为原码。
我们假设已知一个8位二进制补码的值为11111010，现在要将它转换为原码：
11111010   -10000110 除了符号位，按位取反+1 原码加负号。

11.部署防火墙/安装并及时升级防病毒软件/部署入侵检测系统
部署防火墙有助于保护计算机**网络免受恶意攻击**和**未经授权的访问**
安装并及时升级防病毒软件：安装并及时升级防病毒软件是可以有效防治计算机病毒的策略。防病毒软件可以通过监控系统中出现的病毒、木马等恶意软件进行实时监控和处理，以保护计算机系统的安全。
部署入侵检测系统：部署入侵检测系统可以帮助企业监控其计算机网络系统中的安全事件，并及时发现和响应入侵威胁。

12.AES/RSA/MD5/SHA-1

A.公钥加密    B.流密码    C.分组加密    D.消息摘要

AES是一种分组加密算法：其加密过程中将明文数据分成固定长度的数据块进行加密。

RSA：公钥加密：RSA算法基于质因数分解难题，即将一个大整数分解为两个质数的乘积。非对称加密

MD5/SHA-1/SHA-256 消息摘要算法：任意长的消息输入输出到固定长度。

流密码：对称加密，基于密钥生成的伪随机比特序列。

13.IGMP/SSH/Telnet/RFB
IGMP:IP网路上实现对多组播加入，离开，查询
SSH：加密网络协议，用来文件传输或者远程登录。
Telnet：网络协议，用来远程登录，文件传输
RFB：远程桌面控制协议

14.包过滤防火墙对（ 网络层）的数据报文进行检查。

网络层负责：IP地址和路由选择。

15.防火墙通常分为内网、外网和DMZ三个区域，按照受保护程度，从低到高正确的排列次序为（ ）
答：按照受保护程度，从低到高的排列次序为：外网、DMZ、内网。外网是互联网，它是最不受保护的区域，因为它可以随意被任何人访问。DMZ（Demilitarized Zone）区域通常是指介于内外网之间的一层网络，用于存放Web服务器、邮件服务器等对外提供服务的应用程序。DMZ比外网受保护，但比内网不受保护。最后是内网，它包含公司网络中最重要和最敏感的资源，如数据库服务器、文件服务器等。因此，内网需要最高级别的安全保护。

16.是构成我国保护计算机软件著作权的两个基本法律文件。

A.《计算机软件保护条例》和《软件法》

B.《中华人民共和国著作权法》和《软件法》

C.《中华人民共和国著作权法》和《计算机软件保护条例》

D.《中华人民共和国版权法》和《中华人民共和国著作权法》

C 

17.增量模型

增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。此外，它还具有以下优点：第一个可交付版本所需要的成本和时间很少；开发由增量表示的小系统所承担的风险不大：由于很快发布了第一个版本，因此可以减少用户需求的变更：运行增量投资，即在项目开始时，可以仅对一个或两个增量进行投资。增量模型有以下不足之处：如果没有对用户变更的要求进行规划，那么产生的初始量可能会造成后来增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力。

18.敏捷统一过程(AUP) 的叙述
- 在大型任务上连续
- 在小型活动上迭代
- 每一个不同的系统都需要一套不同的策略、约定和方法论
  
敏捷统一过程（Agile Unified Process，AUP）是一个轻量级的、面向对象的软件开发方法，相较于传统的UP方法，它更加灵活、简化和具有迭代方式。在AUP中，虽然仍然包括初始、精化、构建和转换这四个阶段，但是每个阶段都是连续的迭代，并非经典的UP方法中那样分成固定的几个阶段。


19.极限编程（XP）/水晶法（Crystal）/并列争球法（Scrum）/自适应软件开发（ASD

极限编程（XP）强调团队合作、快速反馈和频繁交付等原则。它涉及到持续集成、测试驱动开发、重构和简单设计等实践。

水晶法（Crystal）是由Alistair Cockburn提出的一组方法论。它包括多种不同规模和复杂度的"水晶"，每种水晶都有其对应的开发方法和过程。

并列争球法（Scrum）是由Ken Schwaber 和Jeff Sutherland提出的一种增量式、迭代式软件开发方法。它强调团队合作、产品所有者驱动、时间盒和可视化等概念。

自适应软件开发（ASD）是一种根据项目需要自适应调整的软件开发方法。在ASD中，开发人员需要灵活地选择和使用各种技术和工具，同时也需要关注项目的变化和风险等因素。

20.硬盘的格式化容量
```
假设某硬盘由 5 个盘片构成（共有 8 个记录面），盘面有效记录区域的外直径为 30cm，内直径为 10cm，记录位密度为 250 位/mm，磁道密度为 16 道/mm，每磁道分 16 个扇区，每扇区 512字节，则该硬盘的格式化容量约为 （ ） MB

8（30-10）*10*16*16*512 /(2*1024*1024)
```
21.虚拟存储器/高速存储器/相联存储器/随机访问存储器
虚拟存储器：将不长用的数据暂时保存到磁盘等外部存储设备上，更具需求重新读区到内存。
高速存储器：速度较快的内存和缓存 Cache/SRAM
随机访问存储器： RAM/SARM/DRAM，可随机访问任意单元的存储设备。
相联存储器：使用类似哈希表的方式实现数据的存储和检索。相联存储器主要由两个部分组成，一个是存储数据的内容部分，另一个是用于比较查找的标签部分。在进行数据检索时，系统会将待查找数据的标签与所有存储数据的标签进行比较，如果匹配成功，则返回相应数据的内容；否则返回未找到的错误信息。

22.负数的补码和移码
```
原码
10000011
补码： 11111100+1= 11111101
移码：
11111100

```

23.-0的原码
```
原码：1
补码：1
移码：0
X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101，[X]移=01010101
原码:1101011
反码:1010100
补码:1010101
移码:0010101
```

24.某指令流水线由5段组成，第1、3、5段所需时间为Δt，第2、4段所需时间分别为3Δt、2Δt，如下图所示，那么连续输入n条指令时的吞吐率（单位时间内执行的指令个数）TP为（）
```
TP=指令总数÷执行这些指令所需要的总时间。执行这些指令所需要的总时间=（Δt+3Δt+Δt+2Δt+Δt）+3（n-1)Δt
```

25.漏洞扫描系统
自动化检测计算机系统、应用程序或网络中的漏洞的软件工具。这些漏洞可以用来攻击计算机系统，从而破坏、盗取或损害数据和系统。漏洞扫描器使用各种技术来识别和利用常见的安全漏洞，例如密码弱点、SQL注入、跨站点脚本等。

26.反编译 反汇编 交叉编译
编译是将高级语言源程序翻译成机器语言程序（汇编形式或机器代码形式），反编译是编译的逆过程。反编译通常不能把可执行文件还原成高级语言源代码，只能转换成功能上等价的汇编程序。

反汇编 (Disassembly)：是将机器语言指令转换为汇编语言指令的过程。反汇编的主要目的是获取已编译程序的汇编代码，以便分析和理解程序的操作方式。

交叉编译 (Cross Compilation)：是指在一台计算机上进行的编译过程，生成运行在不同体系结构计算机或者操作系统上的二进制文件。例如，在 Windows 上编译 Linux 可执行文件就属于交叉编译。

27.电梯调度
```
https://blog.csdn.net/m0_58153897/article/details/127610506
```

28.设系统中有 R 类资源 m 个，现有 n 个进程互斥使用。若每个进程对 R 资源的最大需求 为 w发生死锁的情况。

```
轮流给每个进程分配资源，如果存在资源被分配完，但是没有一个进程被满足，那么发生死锁。
```

29.`某文件系统采用索引节点管理，其磁盘索引块和磁盘数据块大小均为1KB字节且每个文件索引节点有8个地址项iaddr[0]~iaddr[7]，每个地址项大小为4字节，其中iaddr[0]~iaddr[4]采用直接地址索引，iaddr[5]和iaddr[6]采用一级间接地址索引，iaddr[7] 采用二级间接地址索引。若用户要访问文件userA中逻辑块号为4和5的信息，则系统应分别采用( )， 该文件系统可表示的单个文件最大长度是( )KB。`

```
0-4为直接索引，逻辑块0-4
1KB/4B= 1024B/4B=256
5 可以指256个索引块
6 可以指256个索引块
7 可以指256*256=65535个
4+256*2+65535=66053
```

30.RUP：初始——细化——构建——移交
RUP将软件开发过程划分为4个阶段：初始阶段、细化阶段、构建阶段和移交阶段。每个阶段都包括多个迭代循环，在每个迭代中，都要完成一定的工作、得出一定的成果，同时进行评审和审核，以确保项目进展按计划顺利进行。RUP还提供了许多最佳实践，如用例驱动开发、迭代和增量开发、模型驱动架构等，可帮助开发团队更好地实现需求收集、分析、设计、测试和部署等工作。


31.软件复审

开发阶段——保证可维护
系统分析阶段的复审过程——指出软件的可移植性以及影响维护的系统界面。
系统分析阶段的复审期间——从容易修改，模块化，功能独立出发，评价软件结构和过程。
系统实施的复审——强调编码风格和内部说明文档。

32.依赖关系/组合关系/聚合关系
依赖关系：
若类 A 仅在其方法 Method1 中定义并使用了类 B 的一个对象，类 A 其他部分的代码都不涉及类 B，那么类 A 与类 B 的关系是依赖关系。因为类 A 只在其中的一个方法中使用到了类 B，而且没有持有或者继承类 B，所以这种关系可以称为依赖关系。
```java
public class Adder {
    public int add(int a, int b) {
        return Math.addExact(a, b);
    }
}
```
聚合关系
假设我们要设计一个学校管理系统，其中有一个班级（Class）类和一个学生（Student）类，一个班级中包含多个学生，同时一个学生也只能归属于一个班级。那么 Class 类可能被设计为包含一个 Student 类型的数组属性，代码如下：
```java
public class Class {
    private Student[] students;

    public Class(Student[] students) {
        this.students = students;
    }

    public Student[] getStudents() {
        return students;
    }
}
```

组合关系
假设我们要设计一个图书馆系统，其中有一个 Book 类和一个 Library 类。该系统需要保证只有当还完所有借书记录之后，才能将一本书从库存中移除。因此，一个 Library 实例可能会持有多个 Book 类的实例，并且当这个 Library 实例被销毁时，其所有的 Book 实例也应该随之被销毁。代码如下：

```java
public class Library {
    private List<Book> books;

    public Library(List<Book> books) {
        this.books = books;
    }

    // 其他方法省略...

    @Override
    protected void finalize() throws Throwable {
        for (Book book : books) {
            book.finalize();
        }
        super.finalize();
    }
}

public class Book {
    // 其他属性、方法等省略...

    @Override
    protected void finalize() {
        System.out.println("Book instance is going to be destroyed.");
    }
}

```

33.1NF/2NF/3NF/BCNF
1NF：第一范式，保证每个属性具有原子性，也就是确保每个属性不能再分成更小的部分。如果出现复合属性，则需要将其拆分成独立的属性。同时，每个属性的值都是单一的，不能包含多个值。

2NF：第二范式，要求实体的非主属性必须完全依赖于主键。也就是说，任何一个非主属性不能依赖于主键的一部分，而应该依赖于整个主键。

3NF：第三范式，要求在2NF基础上，除了主键之外的其他属性之间不能存在传递依赖关系。也就是说，如果 A → B，B → C，那么就要把 B 从表中剥离出来，形成两张表。

BCNF：巴斯-科德范式，是指消除所有属性对于候选键的部分和传递函数依赖关系。通俗的解释是，表中的每个属性都依赖于整个候选键，而不是依赖于候选键的一部分。




34.自然连接

自然连接（Natural Join）是一种基于两张或多张表之间相同列名的连接方式，它会将这些相同列名的列作为连接条件进行匹配，并返回所有满足条件的行。

自然连接不需要指定连接条件，因为它会自动根据列名相同的列进行连接。例如，假设有两张表A和B，它们都包含一个叫做“id”的列，那么使用自然连接对这两张表进行连接操作时，会自动将A表中的"id"列与B表中的"id"列进行匹配，返回所有匹配成功的记录。

自然连接的语法格式如下：
```
SELECT *
FROM table1
NATURAL JOIN table2;
```
35.强连通的有向图
一个强连通的有向图中，每个顶点都能到达所有其他顶点，也就是说，对于每一对顶点 (i,j)，都存在从顶点 i 到顶点 j 的路径以及一条从顶点 j 到顶点 i 的路径。因此，如果每个顶点只有出度而没有入度，或者每个顶点只有入度而没有出度，那么该有向图的边数最小，即 E=V-1。反之，当每个顶点既有出度也有入度时，该有向图的边数可以大于 2V。

36.AOV/AOE
AOV网以顶点表示活动，前驱活动优于后继活动完成。AOV网（Activity On Vertex NetWork）用顶点表示活动，边表示活动（顶点）发生的先后关系。**拓扑排序**
AOE网以边表示活动，通常用来估算工程的完成时间。

```go
    result := []int{}
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        // 加入结果集
        result = append(result, node)
        // 不断的从终端节点出发判断能不能达到某个顶点
        for _, v := range reverseGraph[node] {
            inDegrees[v]--
            // 将入度为0的节点入队
            if inDegrees[v] == 0 {
                queue = append(queue, v)
            }
        }
    }
```
37.栈模拟队列

要用两个栈来模拟队列，可以分别定义一个输入栈和一个输出栈。在入队操作时，将元素放入输入栈中；在出队操作时，首先检查输出栈是否为空，如果不为空，则直接从输出栈中弹出一个元素；如果输出栈为空，则将输入栈中的所有元素依次弹出并压入输出栈中，再从输出栈中弹出一个元素。这样就能保证队列的先进先出特性、

38.完全二叉树
直观地来讲，完全二叉树可以看作是将二叉树的节点按照从上到下、从左到右的顺序排列后得到的结果。其中，除了最后一层之外，其他所有层都填满了节点，最后一层的节点都靠左排列。

39.XML
XML文件的第一行必须是声明该文件是XML文件,以及它所使用的XML规范版本。在文件的前面不能够有其他元素或者注释。所有的XML文档必须由一个根元素。xML文档中第一个元素就是根元素。所有XML文档必须包含一个单独的标记来定义，所有其他元素都必须成对地在根元素中嵌套。XML文档有且只能有一个根元素，所有的元素都可以有子元素，子元素必须正确地嵌套在父元素中，在XML中规定，所有标识必须成对出现，有一个开始标识，就必须有一个结束标识，否则将被视为错误。

40.CISC/RISC

CISC代表复杂指令集计算机，RISC代表精简指令集计算机。

CISC处理器拥有大量的复杂指令，能够在一条指令中执行多个低级操作。这使得CISC处理器能够用更少的指令执行复杂操作，但同时也使得硬件设计更加复杂。

相比之下，RISC处理器只有较小的、更简单的指令集合，每条指令只执行一个操作。这意味着执行复杂操作需要更多的指令，但硬件设计更为简单，处理器可以更快地执行指令。

这两种体系结构都有各自的优缺点，选择哪种取决于项目的具体需求。CISC处理器通常用于需要快速执行复杂指令的应用程序，而RISC处理器通常用于需要快速执行简单指令或者对功耗有要求的应用程序。RISC采用硬布线控制逻辑结构。

41.浮点数
浮点数的一般表示形式为N = 2E × F，其中 E 为阶码，F 为尾数。业标准 IEEE754 浮点数格式中阶码采用移码、尾数采用原码表示。规格化表示要求将尾数的绝对值限定在区间`[0.5, 1)`

为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高位数必须是一个有效值，即1/2≤/F1<1，在尾数用补码表示时，
规格化浮点数应满足尾数最高数位与符号位不同，即当1/2≤F
＜1时，应有0.1xX…x形式；当-1≤M<1/2时，应有1.0xX.…x形式。
需要注意的是，当M=1/2时，对于原码来说是规格化数，而对于补码来说不是规格化数。
两个浮点数进行相加运算时，首先需要对阶（使它们的阶码一致），然后再进行尾数的相加处理。

42.海明码是一种可以纠正一位差错的编码。它是利用信息位为k位，增加r位元余位，构成一个n=k+r位的码字，然后用个个监督关系式产生的r个校正因子来区分无错和在码字中的n个不同位置的一位错。海明码是利用**奇偶性来检错和纠错**的校验方法。海明码的构成方法是：在数据位之间插入k个校验位，通过扩大码距来实现检错和纠错。

43.CRC
循环冗余校验码(CRC码，CRC=Cyclic Redundancy Check)：是数据通信领域中最常用的一种差错校验码，其特征是信息字段和校验字段的长度可以任意选定。（2)生成CRC码的基本原理：任意一个由二进制位串组成的代码都可以和一个系数仅为‘の'和“1'取值的多项式一一对应。例如：代码1010ll对应的多项式为x6+x4+x2+x+1，而多项式为
×5+×3+×2+×+1对应的代码101111。
CRC的计算过程大致如下：

选择一个生成多项式，它通常是一个二进制数，例如x^3 + x + 1，表示为二进制数 1011。

将原始数据转换成一个二进制数。

将生成多项式左移（相当于在最高位加一个0），直到它的最高位是1。

将生成多项式与数据进行按位异或（XOR）运算。

重复步骤4，直到数据的最高位被异或完毕。

将余数作为校验码。

44.Cache
主要由两部分组成:
- 控制部分和Cache存储部分。
- Cache存储部分用来存 放主存的部分拷贝(备份)。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中；若不在则没有命中。命中时直接对Cache存储器寻址。未命中时，若是读取操作，则从主存中读取数据，并按照确定的替换原则把该数据写入Cache存储器中；若是写入操作，则将数据写入主存即可。

45.CA
数字证书是由权威机构—CA证书授权(Certificate Authority)中心发行的，能提供在lnternet上进行身份验证的一种杈威性电子文档，人们可以在互联网交往中用它来证明自己的身份和识别对方的身份。数宇证书采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己设定一把特定的仅为本人所有的私有密钥(私钥)，用它进行解密和签名；同时设定一把公共密钥(公钥)并由本人公开，为一组用户所共享，用于加密和验证签名。当发送一份保密文件时，**发送方使用接收方的公钥对数据加密**，而接收方则使用自己的私钥解密，这样信息就可以安全无误地到达目的地了。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。公开密钥技术解決了密钥发布的管理问题，用户可以公开其公开密钥，而保留其私有密钥。

46.位图/矢量图
矢量图形是用一系列**计算机指令**来描述和记录一幅图的内容，即通过指令描述构成一幅图的所有直线、曲线、圆、圆弧、矩形等图元的位置、堆数和形状，也可以用更为复杂的形式表示图形图像，在处理图形图像时根据图元对应的数学表达式进行编辑和处理。在屏幕上显示一幅图形图像时，首先要解释这些指令，然后将描述图形图像的指令转化成屏幕上显示的形状和颜色。编辑矢量图的软件通称称为绘图软件，如适于绘制机械图、电路图的Auto CAD软件等。这种软件可以产生和操作矢量图的各个成分，并对矢量图形进行移动、缩放、叠加、旋转和扭曲等变化。编辑图像时将指令转变成屏幕上所显示的形状和颜色，显示时也往往能看到绘图的过程。由于所有的矢量图形部分都可以用数学的方法加以描述，从而使得计算机可以对其进行任意放大、缩小、旋转、变形、扭曲、移动和叠加等变换，而不会破坏图像的画面，但是，用矢量图形格式表示复杂图像（如人物、风景照片），并且要求很高时，将需要花费大量的时间进行变换、着色和处理光照效果等。因此，矢量图形主要用于标识线框型的图画、工程制图和美术字等。
位图图像是指用**像素点来描述的图**，图像一般是用摄像机或扫描仪等输入设备捕捉实际场景画面，离散化为空间、亮度、颜色（交度）的序列值，即把一幅彩色图或灰度图分为许许多多的像素（点），每个像素用若干二进制位来指定该像素的颜色、亮度和属性。为因图像在计算机内存中由一组二进制位组成，这些位定义图像中每个像素点的颜色和亮度，图像适合于 表现比较细腻，层次较多，色彩较丰富，包含大量细节的图像，并可直接、快速地在屏幕上显示出来，但占用存储空间较大，一般需要进行数据压缩。

47.面向对象分析与设计

OMT (Object Modeling Technique)、Coad-Yourdon Method 和 Booch Method 都是面向对象分析与设计（OOAD）方法。

OMT 是由 James Rumbaugh 等人提出的一种面向对象分析和设计方法，主要提供了对象建模、动态建模和功能建模等方面的技术。OMT 的核心概念包括类、对象、继承、聚合、关联、操作、消息等。常用的建模符号包括类图、对象图、状态图、活动图等。

Coad-Yourdon Method 最初是由 Coad 和 Yourdon 提出的结构化分析与设计方法改进而来。它在传统的结构化分析和设计方法的基础上，引入了面向对象的概念和技术，具有良好的可视化效果和易学习的特点。
Coad-Yourdon 方法主要包括三个阶段：领域建模、系统建模和对象建模。其中，领域建模定义了系统所涉及的领域和相关概念；系统建模定义了系统的结构和功能；对象建模则定义了系统中的对象、类和关系。

Booch Method 是 Grady Booch 提出的一种面向对象软件开发方法，提供了用于对象建模、动态建模和物理建模等方面的技术。
Booch Method 强调了面向对象分析、设计和实现中的可重用性和模块化，并提供了符号和图形语言来描述对象、类、继承、多态性、消息等，同时也提供了用于系统实现和测试的指南和工具

48.中间代码

“中间代码”是一种简单且含义明确的记号系统，与具体的机器无关，可以有若千种形式。可以将**不同的高级程序语言翻译或同一种中问代码**，由于与具体机器无关，使用中问代码有利于进行与机器无关的优化处理，以及提高编译程
序的**可移植性**

49.软件设计原则
模块大小适中。减少调用，多扇入。少扇出。单出口。

50.面向对象技术

面向对象**分析**阶段：认定对象，组织对象，对象问的相互作用，基于对象的操作。
面向对象**设计**阶段：识别类及对象、定义属性、定义服务、识别关系、识别包。
面向对象程序设计：程序设计范型、选择一种OOPL。
面向对象测试：算法层、类层、模板层、系统层。

51.面向对象设计
接口分离原则：使用多个专门的接口要比使用单一的总接口要好。
开放-封闭原则：对扩展开放，对修改关闭。

共同封闭原则：包中的所有类对于同一性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包里
的所有类产生影响，而对于其他的包不造成任何影响。

共同重用原则：一个包里的所有类应该是共同重用的。如果重用了包里的一个类，那么就要重用包中的所有类。

52.归并排序
```go
package main

import "fmt"

func mergeSort(arr []int) []int {
    if len(arr) < 2 {
        return arr
    }
    mid := len(arr) / 2
    return merge(mergeSort(arr[:mid]), mergeSort(arr[mid:]))
}

func merge(left, right []int) []int {
    size, i, j := len(left)+len(right), 0, 0
    slice := make([]int, size, size)
    for k := 0; k < size; k++ {
        if i > len(left)-1 && j <= len(right)-1 {
            slice[k] = right[j]
            j++
        } else if j > len(right)-1 && i <= len(left)-1 {
            slice[k] = left[i]
            i++
        } else if left[i] < right[j] {
            slice[k] = left[i]
            i++
        } else {
            slice[k] = right[j]
            j++
        }
    }
    return slice
}

func main() {
    arr := []int{9, 4, 5, 6, 10, 3, 8, 2, 7, 1}
    fmt.Println("Unsorted array:", arr)
    fmt.Println("Sorted array:  ", mergeSort(arr))
}
```
归并排序最好：NlogN
归并排序最坏：NlogN

53.Huffman 编码
基本思想：使用更短的二进制码来代表出现频率较高的字符，而使用更长的二进制码来代表出现频率较低的字符。

统计出每个字符在文本中出现的频率，并根据频率构建最小堆（即次数最少的元素在前面）。

54.ARP协议/RARP

ARP，即地址解析协议（Address Resolution Protocol），是一种用于将网络层地址（如 IP 地址）解析为链路层地址（如 MAC 地址）的协议。

在一个 IP 网络中，当主机 A 的网络层需要发送数据到另一个主机 B 时，它需要知道目标主机 B 的 MAC 地址以便构建出帧来正确地把数据包发往目标。由于 ARP 协议可以查询目标主机的 MAC 地址，所以在发送数据前通常会先向局域网内广播一个 ARP 请求，该请求同时包含源主机的 IP 和 MAC 地址以及目标主机的 IP 地址。其他主机收到该请求后会检查自己的 IP 地址是否与请求中的目标地址匹配，如果匹配则会返回自己的 MAC 地址给请求方；否则就忽略该请求。

当请求方接收到 ARP 响应时，它将把返回的 MAC 地址缓存起来，以后再向该目标主机发送数据时就可以直接使用该 MAC 地址，无需再进行 ARP 查询。缓存的 ARP 条目有一个存活时间，过期后需要重新查询。

RARP 协议则是将一个 MAC 地址解析为相应的 IP 地址。在某些局域网环境下，由于没有 DHCP 服务器或者其他原因，某些主机可能无法获得自己的 IP 地址。这时候，RARP 就可以帮助它们了。主机会广播一个 RARP 请求消息，请求其它主机帮助它获取自己的 IP 地址。收到请求的主机会根据 MAC 地址查找相应的 IP 地址，并将其返回给请求主机。

55.路由协议

> 是指在计算机网络中，用于维护路由表和决策数据包传输路径的一组规则与协议。
> 静态路由协议：由网络管理员手动配置路由器上的路由表，适用于小型网络或者稳定的网络环境，因为对网络拓扑结构的变化会造成管理上的困难。
> RIP（Routing Information Protocol）：是一种基于距离向量的路由协议。RIP 协议通过交换整个路由表或部分路由表来实现路由信息的传播，同时每隔一段时间会向邻居发送路由通告，并请求邻居发送其相邻路由表，最后选取最优路径作为路由信息。
> BGP（Border Gateway Protocol）：是一种路由协议，主要运用在互联网中的边缘路由器之间，用来交换路由信息，以便于实现路由的选择和控制。BGP 采用了基于路径、自治系统号等多种因素的决策过程，是一种高级的路由协议。
> OSPF（Open Shortest Path First）：是一种链路状态路由协议。OSPF 通过不断地广播链路状态信息来更新本地的链路状态数据库，使用 Dijkstra 算法计算得出全网中各节点之间的最短路径，并维护路由表。

工作原理：

路由协议通过在路由器之间共享路由信息来支持可路由协议，路由信息在相邻路由器之间传递，路由协议创建了路由表，描述了网络的拓扑结构。

56.对称加密/非对称加密

非对称加密：RAS/ECC
对称加密：DES 3DES AES
消息摘要算法：SHA/MD5

57.SQL注入

把SQL语句加入，获取到数据库的访问权限。

58.四层网络模型

链路层：PP2P链路层，为链路加密
网络层：IPSec工作在网络层，为数据报文加密
传输层：Https SSL为传输层以上的数据加密
应用层：TLS为两个通信应用程序之间提供保密性和数据完整性

59.软件详细设计阶段

每个模块进行详细的算法分析，代码设计，输入，输出设计，用户界面设计。

60.软件的概要设计阶段
软件体系结构设计，系统划分模块，确定每个模块的功能，确定每个模块的调用关系，确定模块间的接口。模块间传递的信息。

61.软件可靠性/可维护性/可用性
软件可靠性
```
MTTF/（MTTF+1）
```
可维护性
```
MTTR/（1+MTTR）
```
可用性
```
MTBF/（1+MTBF）
```


63.维护类型

改正性维护：修复错误。
适应性维护：因为外部环境的改变，修改软件
完善性维护：新的功能，新的要求。
预防性维护：预先修改，满足未来。



64.面向对象分析
识别对象-组织对象-描述对象间的关系-确定对象的操作-定义对象的内部信息。



65.稀疏矩阵的十字链表压缩

在节点中除了存储元素值外，还会存储该元素在行列方向上的前驱节点和后继节点。具体来说，每个节点包含以下字段：
```
row：该元素所在的行号。
col：该元素所在的列号。
value：该元素的值。
down：下一个在该元素同一列的节点。
right：下一个在该元素同一行的节点。
rhead：该元素所在行的头节点。
chead：该元素所在列的头节点。
```

66.稀疏矩阵的三元顺序表压缩

稀疏矩阵的三元组表是一种常用的压缩存储方式，可以用于节省稀疏矩阵所需的存储空间。它将矩阵中非零元素的行列坐标和数值存储在一个三元组中，通常采用如下格式表示：

```
(i, j, v)
```

67.排序算法

```go
func InsertSort(arr []int){
    for i:=1;i<len(arr);i++{
        // 找到大于的数字，那么前面的位置就是该数字
        for j:=i-1;i<i;j++{
            if arr[j]>arr[j]{
                arr[j-1],arr[i] = arr[i],arr[j-1]
            }
        }
    }
}

```

```go
func BubbleSort(arr []int){
    for i:=0;i<len(arr)-1;i++{
        // 找到大于的数字，那么前面的位置就是该数字
        for j:=1;j<=len(arr)-1-i;j++{
            if arr[j]<arr[j-1]{
                arr[j-1],arr[i] = arr[i],arr[j-1]
            }
        }
    }
}

```

```go
func SelectSort(arr []int){
    for i:=0;i<len(arr)-1;i++{
        minIndex:=i
        // 找到大于的数字，那么前面的位置就是该数字
        for j:=i+1;j<len(arr);j++{
            if arr[j]<arr[minIndex]{
                minIndex = j
            }
        }
        arr[i] ,arr[minIndex]= arr[minIndex],arr[i]
    }
}

// 堆排序
func heapSort(arr []int) {
    n := len(arr)

    // 构建大根堆
    for i := n/2 - 1; i >= 0; i-- {
        adjustHeap(arr, i, n)
    }

    // 取出堆顶元素，与末尾元素交换位置
    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        adjustHeap(arr, 0, i)
    }
}

// 调整大根堆
func adjustHeap(arr []int, start, end int) {
    temp := arr[start]
    for k := start*2 + 1; k < end; k = k*2 + 1 {
        if k+1 < end && arr[k+1] > arr[k] {
            k++
        }
        if arr[k] > temp {
            arr[start] = arr[k]
            start = k
        } else {
            break
        }
    }
    arr[start] = temp
}

// 快速排序
func quickSort(arr []int, left, right int) {
    if left < right {
        pivotIndex := partition(arr, left, right)
        quickSort(arr, left, pivotIndex-1)
        quickSort(arr, pivotIndex+1, right)
    }
}

// 分区操作
func partition(arr []int, left, right int) int {
    pivot := arr[left]
    for left < right {
        for left < right && arr[right] >= pivot {
            right--
        }
        arr[left] = arr[right]
        for left < right && arr[left] <= pivot {
            left++
        }
        arr[right] = arr[left]
    }
    arr[left] = pivot
    return left
}

// 归并排序
func mergeSort(arr []int) []int {
    length := len(arr)
    if length <= 1 {
        return arr
    }

    mid := length / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])

    return merge(left, right)
}

// 合并两个有序数组
func merge(left []int, right []int) []int {
    result := make([]int, 0)

    for len(left) > 0 && len(right) > 0 {
        if left[0] < right[0] {
            result = append(result, left[0])
            left = left[1:]
        } else {
            result = append(result, right[0])
            right = right[1:]
        }
    }

    result = append(result, left...)
    result = append(result, right...)

    return result
}

```


77.FTP SFTP TFTP ICMP 

FTP：文件传输协议（File Transfer Protocol），它是为在网络上进行文件传输而开发的一种标准协议。
SFTP：安全文件传输协议（Secure File Transfer Protocol），是基于SSH协议之上的一种加密传输文件的协议。SFTP是一种与FTP不同的完全独立的协议。
TFTP：简单文件传输协议（Trivial File Transfer Protocol），TFTP是一个小巧、简单易用的文件传输协议，主要用于无需认证和登录的场景，如在内网中分发软件镜像。
ICMP：Internet控制消息协议（Internet Control Message Protocol），是TCP/IP协议族的一个子协议，它用于在IP网络上发送控制信息。ICMP通常用于网络设备间交换状态信息，比如路由器、交换机等设备所发生的故障以及转发表更改等情况。

78.四层网络模型各层的协议

应用层：HTTP、FTP、SMTP、DNS

HTTP（HyperText Transfer Protocol）：万维网上块数据的传输协议，用于浏览器与Web服务器之间的通信。
FTP（File Transfer Protocol）：用于在网络上进行文件传输的协议。
SMTP（Simple Mail Transfer Protocol）：用于电子邮件的发送和接收协议。
DNS（Domain Name System）：将域名转换为 IP 地址的系统。

传输层：TCP、UDP
TCP（Transmission Control Protocol）：提供端到端的可靠数据传输服务和协议，包括流量控制和错误纠正等机制。
UDP（User Datagram Protocol）：简单的无连接的传输协议，不保证可靠性，但具有较低的延迟和更好地支持广播和多播。

网络层：IP、ICMP、ARP：
IP（Internet Protocol）：负责实现数据包的传输和路由选择。
ICMP（Internet Control Message Protocol）：用于在网络中传递控制消息，例如ping命令使用的“回显请求”和“回显应答”就是基于ICMP的。

ARP（Address Resolution Protocol）：将IP地址转换成MAC地址的协议。
数据链路层：Ethernet、PPP
Ethernet（以太网）：最常见的有线局域网络传输协议。
PPP（Point-to-Point Protocol）：用于在两个计算机之间进行点对点的数据通信。


79.DDOS
DDoS攻击（Distributed Denial-of-Service Attacks）是指攻击者通过利用网络上的大量计算机或网络设备，向目标服务器或网络资源发起大量伪造的请求，以使得正常用户无法访问服务器或网络资源。攻击者会使用包括僵尸网络、木马程序等手段将自己控制的设备进行扫描、感染，并发起DDoS攻击。这种攻击方式具有流量大、占用带宽多、难以防御等特点，严重影响了网站的可用性和稳定性。

80.ACL/SNAT

ACL是Access Control List（访问控制列表）的缩写，它是一种用于网络安全的技术手段。通过在设备上设置ACL规则，可以限制网络数据包在网络中的流动，防止恶意攻击、保障网络安全等。

而SNAT是Source Network Address Translation（源网络地址转换）的缩写，是一种网络地址转换技术。在一个网络中，当**多个主机需要共享同一个公网IP地址时，就需要使用SNAT技术。**
