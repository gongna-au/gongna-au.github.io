---
layout: post
title: 数据库分库分表？
subtitle:
tags: [Mysql ShardingSphere]
---

# 数据库分库分表？

## 1.什么是分库分表？

通过一定的规则，将原本数据量大的数据库拆分成多个单独的数据库，将原本数据量大的表拆分成若干个数据表，使得单一的库、表性能达到最优的效果（响应速度快），以此提升整体数据库性能。

## 2.为什么分库分表?

单个数据库的存储能力是有限的、连接数是有限的，本身就会成为系统的瓶颈，单个表的数据量在百万以内，可以通过添加索引来提升性能。
一旦数据量朝着千万以上的趋势进行增长，那么再怎么优化数据库，性能依旧是下降的。为了减少数据库的负担提升数据库的性能，缩短查询时间，这个时候就需要分库分表。

#### 为什么需要分库？

容量
我们给数据库实例分配的磁盘容量是固定的，数据量持续的大幅增长，用不了多久单机的容量就会承载不了这么多数据，解决办法简单粗暴，加容量！

连接数
单机的容量可以随意扩展，但数据库的连接数却是有限的，在高并发场景下多个业务同时对一个数据库操作，很容易将连接数耗尽导致 too many connections 报错，导致后续数据库无法正常访问。
可以通过 max_connections 查看 MySQL 最大连接数。

```shell
show variables like '%max_connections%'
```

```shell
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| max_connections        | 151   |
| mysqlx_max_connections | 100   |
+------------------------+-------+
```

将原本单数据库按不同业务拆分成订单库、物流库、积分库等不仅可以有效分摊数据库读写压力，也提高了系统容错性。

#### 为什么需要分表？

数据库查询慢的原因有：
1.SQL 没有使用索引
2.like 扫描全表 3.函数计算 4.数据量确实太大了
数据量确实太大了无法通过优化解决。慢的根本原因是：InnoDB 存储引擎，聚簇索引结构的 B+tree 层级变高，磁盘 IO 变多查询性能变慢。

> 单表行数超 500 万行或者单表容量超过 2GB，就推荐分库分表.实际上很多公司单表数据几千万、亿级别仍然不选择分库分表。

## 3.什么时候分库分表?

> 分库分表要解决的是现存海量数据访问的性能瓶颈，对持续激增的数据量所做出的架构预见性。

是否分库分表的关键指标是数据量？

系统在运行初始的时候，每天只有可怜的几十个资源上传，这时使用单库、单表的方式足以支持系统的存储，数据量小几乎没什么数据库性能瓶颈。 2.是否是持续激增的数据量。但某天开始一股神秘的流量进入，系统每日产生的资源数据量暴增至十万甚至上百万级别，这时资源表数据量到达千万级，查询响应变得缓慢，数据库的性能瓶颈逐渐显现。以 MySQL 数据库为例，单表的数据量在达到亿条级别，通过加索引、SQL 调优等传统优化策略，性能提升依旧微乎其微时，就可以考虑做分库分表了。

既然 MySQL 存储海量数据时会出现性能瓶颈，那么我们是不是可以考虑用其他方案替代它？比如高性能的非关系型数据库 MongoDB？

可以，但要看存储的数据类型！现在互联网上大部分公司的核心数据几乎是存储在关系型数据库（MySQL、Oracle 等），因为它们有着 NoSQL 如法比拟的稳定性和可靠性，产品成熟生态系统完善，还有核心的事务功能特性，也是其他存储工具不具备的，而评论、点赞这些非核心数据还是可以考虑用 MongoDB 的。

## 如何分库分表？

> 分库分表的关键：1.对数据如何进行分片？如何让数据路由到不同的库、不同的库中间的不同的表？
> 分库分表的关键：2.对分片的数据如何进行检索/定位？在不同的库，以及不同的表里面检索定位数据？

#### 分库与分表的两种方式（水平）或者（纵向）？

[!]("https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInvcZoP6NdMzl9wr7icXnqYu0VOAD8XKvNJyic36OEC9DfsNgfJkLS5K3w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1")

#### 垂直分库和垂直分表？

垂直分库：**不同的业务数据在不同的数据库里。（用户数据库）（商品数据库）（订单数据库）（卖家数据库）**
垂直分库的好处：**把一个数据库的压力分给了很多数据库。**垂直分库把一个库的压力分摊到多个库，提升了一些数据库性能，但并没有解决由于单表数据量过大导致的性能问题，所以就需要配合后边的分表来解决。

垂直分表：**拆分一个表的字段（当这个表的字段很多的时候）**（拆分出来的字段放在另外一个表，然后通过 ID『自增』和被拆分的表进行关联。）
(服务器 1-Mysql-OrederDatabse-OrderTable | 服务器 1-Mysql-OrederDatabse-OrderTableExpansion)『OrderTable 和 OrderTableExpansion 的字段是不一样的』
垂直分表的好处：**核心表是访问数据量比较大的表，但是因为被拆分后字段变得比较短，加载更多的核心表的数据量（因为 MYSQL 是按照行把数据加载到内存中）**

#### 水平分库和水平分表？

上边垂直分库、垂直分表后还是会存在单库、表数据量过大的问题，当我们的应用已经无法在细粒度的垂直切分时，依旧存在单库读写、存储性能瓶颈，这时就要配合水平分库、水平分表一起了。

水平分库：
**同样的一个表放到不同的数据库**（很多的数据库里面放着相同的表）
(服务器 1-Mysql-OrederDatabse-OrderTable_1 | 服务器 2-Mysql-OrederDatabse-OrderTable_2) 『OrderTable1 和 OrderTable2 的字段是一样的』
举个例子：
db_orde_1、db_order_2 两个数据库内有完全相同的 t_order 表访问某个订单的时候可以通过对订单编号取模的方式，决定把这个订单编号存储在哪个数据库。查询订单的时候，就对订单号取模，决定去哪个数据库查询。

水平分表：
**同样的一个表放到相同的数据库**（相同的数据库里面放着相同的表）
举个例子：
一个 Order 表：900 万数据，放到该数据库下面的相同的三个表 Order_1、Order_2、Order_3 每个数据表 300 万数据。
存在的问题：
水平分表尽管拆分了表，但子表都还是在同一个数据库实例中，只是解决了单一表数据量过大的问题，并没有将拆分后的表分散到不同的机器上，还在竞争同一个物理机的 CPU、内存、网络 IO 等。要想进一步提升性能，就需要将拆分后的表分散到不同的数据库中，达到分布式的效果。

提问：一个 Orders 表，1 水平分表怎么做？2 水平分库怎么做？3 怎么做？ 1.水平分表就是把在一个相同的数据库里面，搞三个 Order_1 、Order_2 、Order_3 这个三个表的字段相同。 2.水平分库就是把在三个数据库里面，搞三个 Orders 、Orders 、Orders 这个三个表的字段相同。

提问：一个 Orders 表，1 垂直分表怎么做？2 垂直分库怎么做？3 怎么做？ 1.垂直分表就是这个表的字段拆成好多部分，然后在这个数据库下面搞出这几个表：Orders OrdersExpansion1 、OrdersExpansion2、OrdersExpansion3、OrdersExpansion4.... 2.垂直分库就是把在这个 Orders 这个表所在的数据库里，只能存放 Orders 这一个表，其他的表就只能放在其他的数据库。

综合来看：一个 Order 表应该这么拆分：
[!]("https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInUm6sQ78O1p1K0wMDYnv8wLsOucdiaiaTicQic7HK9cp5ZF0ehUKXfYqibzw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1")
第一层： DB1 DB2 DB3
第二层：DB1_Order1 DB2_Order2 DB3_Order3
第三层：DB1_Order1_table1 DB2_Order2_table2 DB3_Order3_table2

## 4.数据存在哪个库的表?(数据库的路由算法)

分库分表以后会出现一个问题，一张表会出现在多个数据库里，到底该往哪个库的哪个表里存呢？

上边我们多次提到过一定规则 ，其实这个规则它是一种路由算法，决定了一条数据具体应该存在哪个数据库的哪张表里。
常见的有 取模算法 、范围限定算法、范围+取模算法 、预定义算法

1、取模算法
****
关键字段取模（对 hash 结果取余数 hash(XXX) mod N)，N 为数据库实例数或子表数量）是最为常见的一种路由方式。
以 t_order 订单表为例，先给数据库从 0 到 N-1 进行编号，对 t_order 订单表中 order_no 订单编号字段进行取模 hash(order_no) mod N，得到余数 i。i=0 存第一个库，i=1 存第二个库，i=2 存第三个库，以此类推。
优点
实现简单，数据分布相对比较均匀，不易出现请求都打到一个库上的情况。
缺点
取模算法对集群的伸缩支持不太友好，集群中有 N 个数据库实·hash(user_id) mod N，当某一台机器宕机，本应该落在该数据库的请求就无法得到处理，这时宕掉的实例会被踢出集群。
此时机器数减少算法发生变化 hash(user_id) mod N-1，同一用户数据落在了在不同数据库中，等这台机器恢复，用 user_id 作为条件查询用户数据就会少一部分。

2、范围限定算法
范围限定算法以某些范围字段，如时间或 ID 区拆分。

用户表 t_user 被拆分成 t_user_1、t_user_2、t_user_3 三张表，后续将 user_id 范围为 1 ~ 1000w 的用户数据放入 t_user_1，1000~ 2000w 放入 t_user_2，2000~3000w 放入 t_user_3，以此类推。按日期范围划分同理。
优点
单表数据量是可控的
水平扩展简单只需增加节点即可，无需对其他分片的数据进行迁移.

